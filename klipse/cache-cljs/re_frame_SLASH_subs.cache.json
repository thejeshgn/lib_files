["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$re-frame.subs","~:imports",null,"~:requires",["^ ","~$re-frame.db","^;","~$re-frame.interop","^<","~$re-frame.loggers","^=","~$re-frame.utils","^>","~$re-frame.registrar","^?","~$trace","~$re-frame.trace","^A","^A"],"~:uses",["^ ","~$reagent-id","^<","~$console","^=","~$app-db","^;","~$dispose!","^<","~$add-on-dispose!","^<","~$make-reaction","^<","~$get-handler","^?","~$first-in-vector","^>","~$deref?","^<","~$ratom?","^<","~$debug-enabled?","^<","~$clear-handlers","^?","~$register-handler","^?"],"~:defs",["^ ","~$cache-and-return",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^8","~:line",44,"~:column",7,"~:end-line",44,"~:end-column",23,"~:arglists",["~#list",["~$quote",["^Z",[["~$query-v","~$dynv","~$r"]]]]],"~:doc","cache the reaction r"],"^7","~$re-frame.subs/cache-and-return","~:variadic",false,"^T","re_frame/subs.cljc","^X",23,"~:method-params",["^Z",[["^10","^11","~$r"]]],"~:protocol-impl",null,"~:arglists-meta",["^Z",[null,null]],"^V",1,"^U",44,"^W",44,"~:max-fixed-arity",3,"~:fn-var",true,"^Y",["^Z",["^[",["^Z",[["^10","^11","~$r"]]]]],"^12","cache the reaction r"],"~$deref-input-signals",["^ ","^R",null,"^S",["^ ","^T","^8","^U",126,"^V",8,"^W",126,"^X",27,"~:private",true,"^Y",["^Z",["^[",["^Z",[["~$signals","~$query-id"]]]]]],"^1;",true,"^7","~$re-frame.subs/deref-input-signals","^14",false,"^T","re_frame/subs.cljc","^X",27,"^15",["^Z",[["^1<","^1="]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",126,"^W",126,"^18",2,"^19",true,"^Y",["^Z",["^[",["^Z",[["^1<","^1="]]]]]],"~$subscribe",["^ ","^R",null,"^S",["^ ","^T","^8","^U",69,"^V",7,"^W",69,"^X",16,"^Y",["^Z",["^[",["^Z",[["^10"],["~$v","^11"]]]]],"^12","Returns a Reagent/reaction which contains a computation","~:top-fn",["^ ","^14",false,"^18",2,"^15",["^Z",[["^10"],["~$v","^11"]]],"^Y",["^Z",[["^10"],["~$v","^11"]]],"^17",["^Z",[null,null]]]],"^7","~$re-frame.subs/subscribe","^14",false,"^T","re_frame/subs.cljc","^X",16,"^1@",["^ ","^14",false,"^18",2,"^15",["^Z",[["^10"],["~$v","^11"]]],"^Y",["^Z",[["^10"],["~$v","^11"]]],"^17",["^Z",[null,null]]],"^15",["^Z",[["^10"],["~$v","^11"]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",69,"^W",69,"^18",2,"^19",true,"^Y",["^Z",[["^10"],["~$v","^11"]]],"^12","Returns a Reagent/reaction which contains a computation"],"~$reg-sub",["^ ","^R",null,"^S",["^ ","^T","^8","^U",137,"^V",7,"^W",137,"^X",14,"^Y",["^Z",["^[",["^Z",[["^1=","~$&","~$args"]]]]],"^12","Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  ","^1@",["^ ","^14",true,"^18",1,"^15",[["^Z",["^1=","^1C"]]],"^Y",["^Z",[["^1=","~$&","^1C"]]],"^17",["^Z",[null]]]],"^7","~$re-frame.subs/reg-sub","^14",true,"^T","re_frame/subs.cljc","^X",14,"^1@",["^ ","^14",true,"^18",1,"^15",[["^Z",["^1=","^1C"]]],"^Y",["^Z",[["^1=","~$&","^1C"]]],"^17",["^Z",[null]]],"^15",[["^Z",["^1=","^1C"]]],"^16",null,"^17",["^Z",[null]],"^V",1,"^U",137,"^W",137,"^18",1,"^19",true,"^Y",["^Z",[["^1=","~$&","^1C"]]],"^12","Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  "],"~$query->reaction",["^ ","^7","~$re-frame.subs/query->reaction","^T","re_frame/subs.cljc","^U",18,"^V",1,"^W",18,"^X",21,"^S",["^ ","^T","^8","^U",18,"^V",6,"^W",18,"^X",21],"~:tag","~$any"],"~$clear-all-handlers!",["^ ","^R",null,"^S",["^ ","^T","^8","^U",38,"^V",7,"^W",38,"^X",26,"^Y",["^Z",["^[",["^Z",[[]]]]],"^12","Unregisters all existing subscription handlers"],"^7","~$re-frame.subs/clear-all-handlers!","^14",false,"^T","re_frame/subs.cljc","^X",26,"^15",["^Z",[[]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",38,"^W",38,"^18",0,"^19",true,"^Y",["^Z",["^[",["^Z",[[]]]]],"^12","Unregisters all existing subscription handlers"],"~$cache-lookup",["^ ","^R",null,"^S",["^ ","^T","^8","^U",60,"^V",7,"^W",60,"^X",19,"^Y",["^Z",["^[",["^Z",[["^10"],["^10","~$dyn-v"]]]]],"^1@",["^ ","^14",false,"^18",2,"^15",["^Z",[["^10"],["^10","^1L"]]],"^Y",["^Z",[["^10"],["^10","^1L"]]],"^17",["^Z",[null,null]]]],"^7","~$re-frame.subs/cache-lookup","^14",false,"^T","re_frame/subs.cljc","^X",19,"^1@",["^ ","^14",false,"^18",2,"^15",["^Z",[["^10"],["^10","^1L"]]],"^Y",["^Z",[["^10"],["^10","^1L"]]],"^17",["^Z",[null,null]]],"^15",["^Z",[["^10"],["^10","^1L"]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",60,"^W",60,"^18",2,"^19",true,"^Y",["^Z",[["^10"],["^10","^1L"]]]],"~$map-vals",["^ ","^R",null,"^S",["^ ","^T","^8","^U",117,"^V",8,"^W",117,"^X",16,"^1;",true,"^Y",["^Z",["^[",["^Z",[["~$f","~$m"]]]]],"^12","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"^1;",true,"^7","~$re-frame.subs/map-vals","^14",false,"^T","re_frame/subs.cljc","^X",16,"^15",["^Z",[["~$f","~$m"]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",117,"^W",117,"^18",2,"^19",true,"^Y",["^Z",["^[",["^Z",[["~$f","~$m"]]]]],"^12","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"~$kind",["^ ","^7","~$re-frame.subs/kind","^T","re_frame/subs.cljc","^U",10,"^V",1,"^W",10,"^X",10,"^S",["^ ","^T","^8","^U",10,"^V",6,"^W",10,"^X",10],"^1G","~$cljs.core/Keyword"],"~$clear-subscription-cache!",["^ ","^R",null,"^S",["^ ","^T","^8","^U",20,"^V",7,"^W",20,"^X",32,"^Y",["^Z",["^[",["^Z",[[]]]]],"^12","Runs on-dispose for all subscriptions we have in the subscription cache.\n  Used to force recreation of new subscriptions. Should only be necessary\n  in development.\n\n  The on-dispose functions for the subscriptions will remove themselves from the\n  cache.\n\n  Useful when reloading Figwheel code after a React exception, as React components\n  aren't cleaned up properly. This means a subscription's on-dispose function isn't\n  run when the components are destroyed. If a bad subscription caused your exception,\n  then you can't fix it without reloading your browser."],"^7","~$re-frame.subs/clear-subscription-cache!","^14",false,"^T","re_frame/subs.cljc","^X",32,"^15",["^Z",[[]]],"^16",null,"^17",["^Z",[null,null]],"^V",1,"^U",20,"^W",20,"^18",0,"^19",true,"^Y",["^Z",["^[",["^Z",[[]]]]],"^12","Runs on-dispose for all subscriptions we have in the subscription cache.\n  Used to force recreation of new subscriptions. Should only be necessary\n  in development.\n\n  The on-dispose functions for the subscriptions will remove themselves from the\n  cache.\n\n  Useful when reloading Figwheel code after a React exception, as React components\n  aren't cleaned up properly. This means a subscription's on-dispose function isn't\n  run when the components are destroyed. If a bad subscription caused your exception,\n  then you can't fix it without reloading your browser."]],"~:require-macros",["^ ","^@","^A","^A","^A"],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:dyn-v","^Q","~$&","~:tags","^1:","^1?","~:sub/run","^1O","^1<","^1;","~:else","~:sub","^1B","^1L","^1C","~:sub/create","^1J","~:ns","~:warn","^7","~$r","^14","^T","~$v","~:operation","^X","~:start","^1@","^1E","~:duration","^15","~:query-v","^1T","^1Q","^17","^1M","^V","~$m","^1=","^1A","^13","^U","^10","^1D","^1I","^8","^11","^W","^1>","~:cached?","~:sub/dispose","~:error","^1F","^18","~:input-signals","^1K","^1N","~:end","^Y","^12","~:reaction","~:op-type","^1P","~:test","^1S","~$f"]],"~:order",["^20","^1Q","^22","^7","^T","^X","^V","^U","^W","^Y","^12","^2?","^8","^1P","^1F","^1E","^23","^1T","^1S","^1J","^1I","^24","^2>","^1Y","^29","^27","^2=","^25","^2:","^26","^2<","^13","^Q","^10","^11","~$r","^1M","^1@","^1K","^14","^18","^15","^17","^1L","^1A","^1?","~$v","^21","^28","^1X","^1O","^1;","^1N","~$f","~$m","^1[","^2;","^1>","^1:","^1<","^1=","^1D","^1B","^1C","~$&","^1Z"]],"^12",null]