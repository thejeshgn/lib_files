["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$re-frame.events","~:imports",null,"~:requires",["^ ","~$re-frame.interop","^;","~$re-frame.interceptor","^<","~$re-frame.trace","^=","~$re-frame.registrar","^>","~$interceptor","^<","~$trace","^=","~$re-frame.utils","^A","~$re-frame.loggers","^B","~$re-frame.db","^C"],"~:uses",["^ ","~$console","^B","~$app-db","^C","~$get-handler","^>","~$first-in-vector","^A","~$empty-queue","^;","~$debug-enabled?","^;","~$register-handler","^>"],"~:defs",["^ ","~$flatten-and-remove-nils",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^8","~:line",14,"~:column",8,"~:end-line",14,"~:end-column",31,"~:private",true,"~:arglists",["~#list",["~$quote",["^W",[["~$id","~$interceptors"]]]]],"~:doc","~`interceptors` might have nested collections, and contain nil elements.\n  return a flat collection, with all nils removed.\n  This function is 9/10 about giving good error messages"],"^U",true,"^7","~$re-frame.events/flatten-and-remove-nils","~:variadic",false,"^P","re_frame/events.cljc","^T",31,"~:method-params",["^W",[["^Y","^Z"]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^R",1,"^Q",14,"^S",14,"~:max-fixed-arity",2,"~:fn-var",true,"^V",["^W",["^X",["^W",[["^Y","^Z"]]]]],"^[","~`interceptors` might have nested collections, and contain nil elements.\n  return a flat collection, with all nils removed.\n  This function is 9/10 about giving good error messages"],"~$register",["^ ","^N",null,"^O",["^ ","^P","^8","^Q",35,"^R",7,"^S",35,"^T",15,"^V",["^W",["^X",["^W",[["^Y","^Z"]]]]],"^[","Associate the given event `id` with the given collection of `interceptors`.\n\n   `interceptors` may contain nested collections and there may be nils\n   at any level,so process this structure into a simple, nil-less vector\n   before registration.\n\n   An `event handler` will likely be at the end of the chain (wrapped in an interceptor)."],"^7","~$re-frame.events/register","^11",false,"^P","re_frame/events.cljc","^T",15,"^12",["^W",[["^Y","^Z"]]],"^13",null,"^14",["^W",[null,null]],"^R",1,"^Q",35,"^S",35,"^15",2,"^16",true,"^V",["^W",["^X",["^W",[["^Y","^Z"]]]]],"^[","Associate the given event `id` with the given collection of `interceptors`.\n\n   `interceptors` may contain nested collections and there may be nils\n   at any level,so process this structure into a simple, nil-less vector\n   before registration.\n\n   An `event handler` will likely be at the end of the chain (wrapped in an interceptor)."],"~$*handling*",["^ ","^O",["^ ","^P","^8","^Q",50,"^R",16,"^S",50,"^T",26,"~:dynamic",true],"^7","~$re-frame.events/*handling*","^P","re_frame/events.cljc","^T",26,"^R",1,"^1:",true,"^Q",50,"^S",50,"~:tag","~$clj-nil"],"~$kind",["^ ","^7","~$re-frame.events/kind","^P","re_frame/events.cljc","^Q",11,"^R",1,"^S",11,"^T",10,"^O",["^ ","^P","^8","^Q",11,"^R",6,"^S",11,"^T",10],"^1<","~$cljs.core/Keyword"],"~$handle",["^ ","^N",null,"^O",["^ ","^P","^8","^Q",52,"^R",7,"^S",52,"^T",13,"^V",["^W",["^X",["^W",[["~$event-v"]]]]],"^[","Given an event vector, look up the associated intercepter chain, and execute it."],"^7","~$re-frame.events/handle","^11",false,"^P","re_frame/events.cljc","^T",13,"^12",["^W",[["^1B"]]],"^13",null,"^14",["^W",[null,null]],"^R",1,"^Q",52,"^S",52,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["^1B"]]]]],"^[","Given an event vector, look up the associated intercepter chain, and execute it."]],"~:require-macros",["^ ","^@","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["^Z","~:tags","^8","^U","^18","^1?","^1;","~:ns","^7","^1C","^P","~:operation","^T","~:start","~:duration","^R","~:event","^1:","^Q","^M","^S","~:error","^10","~:end","^V","^Y","^17","^[","^1B","^19","~:op-type","^1>","^1A","~:test"]],"~:order",["^1L","^1?","^1H","^7","^P","^T","^R","^Q","^S","^V","^[","^1P","^8","^1>","^1M","^10","^U","^M","^Y","^Z","^18","^17","^1;","^1:","^19","^1I","^1O","^1G","^1J","^1K","^1N","^1C","^1A","^1B"]],"^[",null]