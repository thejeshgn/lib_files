["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.template$macros","~:imports",null,"~:requires",["^ ","~$walk","~$clojure.walk","^<","^<"],"~:uses",null,"~:defs",["^ ","~$do-template",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$clojure.template","~:end-column",22,"~:top-fn",["^ ","~:variadic",true,"~:max-fixed-arity",4,"~:method-params",[["~#list",["~$&form","~$&env","~$argv","~$expr","~$values"]]],"~:arglists",["^I",[["^J","^K","^L","^M","~$&","^N"]]],"~:arglists-meta",["^I",[null]]],"~:column",11,"~:line",45,"~:macro",true,"~:end-line",45,"^O",["^I",["~$quote",["^I",[["^L","^M","~$&","^N"]]]]],"~:doc","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"],"^7","~$clojure.template$macros/do-template","^F",true,"^B","clojure/template.clj","^D",22,"^E",["^ ","^F",true,"^G",4,"^H",[["^I",["^J","^K","^L","^M","^N"]]],"^O",["^I",[["^J","^K","^L","^M","~$&","^N"]]],"^P",["^I",[null]]],"^H",[["^I",["^J","^K","^L","^M","^N"]]],"~:protocol-impl",null,"^P",["^I",[null]],"^Q",1,"^R",45,"^S",true,"^T",45,"^G",4,"~:fn-var",false,"^O",["^I",[["^J","^K","^L","^M","~$&","^N"]]],"^V","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"],"~$apply-template",["^ ","^@",null,"^A",["^ ","^B","^C","^R",30,"^Q",7,"^T",30,"^D",21,"^O",["^I",["^U",["^I",[["^L","^M","^N"]]]]],"^V","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"^7","~$clojure.template$macros/apply-template","^F",false,"^B","clojure/template.clj","^D",21,"^H",["^I",[["^L","^M","^N"]]],"^X",null,"^P",["^I",[null,null]],"^Q",1,"^R",30,"^T",30,"^G",3,"^Y",true,"^O",["^I",["^U",["^I",[["^L","^M","^N"]]]]],"^V","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"]],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~$&","^8","~:ns","^7","^J","^F","^B","^D","^E","^?","~$do","^H","^Z","^P","^Q","^R","^S","^W","^K","^T","^[","^L","^G","^O","^M","^N","^V","~:test"]],"~:order",["^[","^13","^7","^B","^D","^Q","^R","^T","^O","^V","^15","^8","^Z","^L","^M","^N","^W","^E","^S","^?","^F","^G","^H","^P","^J","^K","~$&","^14"]],"^V",null]