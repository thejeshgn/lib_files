["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","~$clojure.set","^9","~$clojure.string","^:","~$zip","~$clojure.zip","^<","^<"],"~:uses",["^ ","~$join","^:","~$split-lines","^:","~$blank?","^:"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^6","~:line",429,"~:column",7,"~:end-line",429,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^K",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^5","~$gadjett.collections/unflatten-keys","~:variadic",false,"^E","gadjett/collections.cljc","^I",21,"~:method-params",["^K",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^K",[null,null]],"^G",1,"^F",429,"^H",429,"~:max-fixed-arity",1,"~:fn-var",true,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^C",null,"^D",["^ ","^E","^6","^F",110,"^G",7,"^H",110,"^I",20,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n~~~klipse\n  (sequence->map [10 20 30])\n~~~\n  "],"^5","~$gadjett.collections/sequence->map","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",110,"^H",110,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n~~~klipse\n  (sequence->map [10 20 30])\n~~~\n  "],"~$=without-keys?",["^ ","^C",null,"^D",["^ ","^E","^6","^F",9,"^G",7,"^H",9,"^I",21,"^J",["^K",["^L",["^K",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^M","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^5","~$gadjett.collections/=without-keys?","^O",false,"^E","gadjett/collections.cljc","^I",21,"^P",["^K",[["^X","^Y","^Z"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",9,"^H",9,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["^X","^Y","^Z"]]]]],"^M","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^C",null,"^D",["^ ","^E","^6","^F",284,"^G",7,"^H",284,"^I",16,"^J",["^K",["^L",["^K",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^M","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^5","~$gadjett.collections/dissoc-in","^O",false,"^E","gadjett/collections.cljc","^I",16,"^P",["^K",[["~$m","~$p__213"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",284,"^H",284,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$m",["~$k","~$&","^11","^12","^13"]]]]]],"^M","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^C",null,"^D",["^ ","^E","^6","^F",340,"^G",7,"^H",340,"^I",35,"^J",["^K",["^L",["^K",[["~$coll","~$pred","~$n","~$d"]]]]],"^M","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^5","~$gadjett.collections/split-by-predicate-positions","^O",false,"^E","gadjett/collections.cljc","^I",35,"^P",["^K",[["^17","^18","~$n","~$d"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",340,"^H",340,"^S",4,"^T",true,"^J",["^K",["^L",["^K",[["^17","^18","~$n","~$d"]]]]],"^M","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^C",null,"^D",["^ ","^E","^6","^F",261,"^G",7,"^H",261,"^I",13,"^J",["^K",["^L",["^K",[["~$f","~$s"]]]]],"^M","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^5","~$gadjett.collections/mapify","^O",false,"^E","gadjett/collections.cljc","^I",13,"^P",["^K",[["~$f","~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",261,"^H",261,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","~$s"]]]]],"^M","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^C",null,"^D",["^ ","^E","^6","^F",373,"^G",7,"^H",373,"^I",14,"^J",["^K",["^L",["^K",[["~$m1","~$m2"]]]]],"^M","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^5","~$gadjett.collections/submap?","^O",false,"^E","gadjett/collections.cljc","^I",14,"^P",["^K",[["^1=","^1>"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",373,"^H",373,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^1=","^1>"]]]]],"^M","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^C",null,"^D",["^ ","^E","^6","^F",309,"^G",7,"^H",309,"^I",16,"^J",["^K",["^L",["^K",[["~$coll-of-lengths","~$&",["^ ","~:or",["^ ","~$first-val",0,"~$max-val","~$infinity"],"~:keys",["^1D","^1C"]]]]]]],"^M","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^O",true,"^S",1,"^P",[["^K",["^1A",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^J",["^K",[["^1A","~$&",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^R",["^K",[null]]]],"^5","~$gadjett.collections/positions","^O",true,"^E","gadjett/collections.cljc","^I",16,"^1G",["^ ","^O",true,"^S",1,"^P",[["^K",["^1A",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^J",["^K",[["^1A","~$&",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^R",["^K",[null]]],"^P",[["^K",["^1A",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^Q",null,"^R",["^K",[null]],"^G",1,"^F",309,"^H",309,"^S",1,"^T",true,"^J",["^K",[["^1A","~$&",["^ ","^1B",["^ ","^1C",0,"^1D","^1E"],"^1F",["^1D","^1C"]]]]],"^M","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^C",null,"^D",["^ ","^E","^6","^F",205,"^G",7,"^H",205,"^I",17,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Run a function on the elements of a map and keep only those elements for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^5","~$gadjett.collections/filter-map","^O",false,"^E","gadjett/collections.cljc","^I",17,"^P",["^K",[["~$f","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",205,"^H",205,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Run a function on the elements of a map and keep only those elements for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^C",null,"^D",["^ ","^E","^6","^F",19,"^G",7,"^H",19,"^I",15,"^J",["^K",["^L",["^K",[["~$vec"]]]]],"^M","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^5","~$gadjett.collections/vec->map","^O",false,"^E","gadjett/collections.cljc","^I",15,"^P",["^K",[["^1L"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",19,"^H",19,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["^1L"]]]]],"^M","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^C",null,"^D",["^ ","^E","^6","^F",161,"^G",7,"^H",161,"^I",19,"^J",["^K",["^L",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]]]],"^M","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1G",["^ ","^O",false,"^S",4,"^P",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^J",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^R",["^K",[null,null]]]],"^5","~$gadjett.collections/assoc-cyclic","^O",false,"^E","gadjett/collections.cljc","^I",19,"^1G",["^ ","^O",false,"^S",4,"^P",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^J",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^R",["^K",[null,null]]],"^P",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",161,"^H",161,"^S",4,"^T",true,"^J",["^K",[["^17","~$k","~$v"],["^17","~$k","~$v","~$n"]]],"^M","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1E",["^ ","^5","~$gadjett.collections/infinity","^E","gadjett/collections.cljc","^F",6,"^G",1,"^H",6,"^I",14,"^D",["^ ","^E","^6","^F",6,"^G",6,"^H",6,"^I",14]],"~$subsequence",["^ ","^C",null,"^D",["^ ","^E","^6","^F",388,"^G",7,"^H",388,"^I",18,"^J",["^K",["^L",["^K",[["^17","~$start","~$end"]]]]],"^M","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^5","~$gadjett.collections/subsequence","^O",false,"^E","gadjett/collections.cljc","^I",18,"^P",["^K",[["^17","^1R","^1S"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",388,"^H",388,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["^17","^1R","^1S"]]]]],"^M","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^C",null,"^D",["^ ","^E","^6","^F",546,"^G",7,"^H",546,"^I",14,"^J",["^K",["^L",["^K",[["~$root"]]]]],"^M","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^5","~$gadjett.collections/edn-zip","^O",false,"^E","gadjett/collections.cljc","^I",14,"^P",["^K",[["^1V"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",546,"^H",546,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["^1V"]]]]],"^M","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^C",null,"^D",["^ ","^E","^6","^F",612,"^G",7,"^H",612,"^I",22,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^5","~$gadjett.collections/fix-blank-lines","^O",false,"^E","gadjett/collections.cljc","^I",22,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",612,"^H",612,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^C",null,"^D",["^ ","^E","^6","^F",251,"^G",7,"^H",251,"^I",20,"^J",["^K",["^L",["^K",[["~$f","~$lst"]]]]],"^M","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^5","~$gadjett.collections/map-to-object","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["~$f","^1["]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",251,"^H",251,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","^1["]]]]],"^M","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^C",null,"^D",["^ ","^E","^6","^F",468,"^G",7,"^H",468,"^I",17,"^J",["^K",["^L",["^K",[["~$&","~$maps"]]]]],"^M"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^22"]]],"^J",["^K",[["~$&","^22"]]],"^R",["^K",[null]]]],"^5","~$gadjett.collections/deep-merge","^O",true,"^E","gadjett/collections.cljc","^I",17,"^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^22"]]],"^J",["^K",[["~$&","^22"]]],"^R",["^K",[null]]],"^P",[["^K",["^22"]]],"^Q",null,"^R",["^K",[null]],"^G",1,"^F",468,"^H",468,"^S",0,"^T",true,"^J",["^K",[["~$&","^22"]]],"^M"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^C",null,"^D",["^ ","^E","^6","^F",98,"^G",7,"^H",98,"^I",11,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^5","~$gadjett.collections/mean","^O",false,"^E","gadjett/collections.cljc","^I",11,"^P",["^K",[["~$x"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",98,"^H",98,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^C",null,"^D",["^ ","^E","^6","^F",571,"^G",8,"^H",571,"^I",22,"~:private",true,"^J",["^K",["^L",["^K",[["~$smap","~$loc"]]]]]],"^27",true,"^5","~$gadjett.collections/loc-my-replace","^O",false,"^E","gadjett/collections.cljc","^I",22,"^P",["^K",[["^28","^29"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",571,"^H",571,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^28","^29"]]]]]],"~$map-object-kv",["^ ","^C",null,"^D",["^ ","^E","^6","^F",73,"^G",7,"^H",73,"^I",20,"^J",["^K",["^L",["^K",[["~$fk","~$fv","~$m"]]]]],"^M","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^5","~$gadjett.collections/map-object-kv","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["^2<","^2=","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",73,"^H",73,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["^2<","^2=","~$m"]]]]],"^M","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$flatten-keys",["^ ","^C",null,"^D",["^ ","^E","^6","^F",418,"^G",7,"^H",418,"^I",19,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^5","~$gadjett.collections/flatten-keys","^O",false,"^E","gadjett/collections.cljc","^I",19,"^P",["^K",[["~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",418,"^H",418,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$flatten-keys*",["^ ","^C",null,"^D",["^ ","^E","^6","^F",411,"^G",8,"^H",411,"^I",21,"^27",true,"^J",["^K",["^L",["^K",[["~$a","^11","~$m"]]]]]],"^27",true,"^5","~$gadjett.collections/flatten-keys*","^O",false,"^E","gadjett/collections.cljc","^I",21,"^P",["^K",[["~$a","^11","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",411,"^H",411,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["~$a","^11","~$m"]]]]]],"~$compactize-map",["^ ","^C",null,"^D",["^ ","^E","^6","^F",195,"^G",7,"^H",195,"^I",21,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^5","~$gadjett.collections/compactize-map","^O",false,"^E","gadjett/collections.cljc","^I",21,"^P",["^K",[["~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",195,"^H",195,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^C",null,"^D",["^ ","^E","^6","^F",516,"^G",7,"^H",516,"^I",24,"^J",["^K",["^L",["^K",[["^18","^17"]]]]],"^M","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^5","~$gadjett.collections/partition-between","^O",false,"^E","gadjett/collections.cljc","^I",24,"^P",["^K",[["^18","^17"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",516,"^H",516,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^18","^17"]]]]],"^M","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^C",null,"^D",["^ ","^E","^6","^F",440,"^G",7,"^H",440,"^I",20,"^J",["^K",["^L",["^K",[["~$n","~$m"]]]]],"^M","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^5","~$gadjett.collections/take-from-map","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["~$n","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",440,"^H",440,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$n","~$m"]]]]],"^M","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$compact",["^ ","^C",null,"^D",["^ ","^E","^6","^F",645,"^G",11,"^H",645,"^I",18,"^J",["^K",["^L",["^K",[["~$x","~$&",["^ ","^12","~$args","^1B",["^ ","~$max-elements-in-coll",10,"~$max-chars-in-str",20],"^1F",["^2K","^2L"]]]]]]],"^M","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1G",["^ ","^O",true,"^S",1,"^P",[["^K",["~$x",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^J",["^K",[["~$x","~$&",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^R",["^K",[null]]]],"^5","~$gadjett.collections/compact","^O",true,"^E","gadjett/collections.cljc","^I",18,"^1G",["^ ","^O",true,"^S",1,"^P",[["^K",["~$x",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^J",["^K",[["~$x","~$&",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^R",["^K",[null]]],"^P",[["^K",["~$x",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^Q",null,"^R",["^K",[null]],"^G",5,"^F",645,"^H",645,"^S",1,"^T",true,"^J",["^K",[["~$x","~$&",["^ ","^12","^2J","^1B",["^ ","^2K",10,"^2L",20],"^1F",["^2K","^2L"]]]]],"^M","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$map-with-index",["^ ","^C",null,"^D",["^ ","^E","^6","^F",274,"^G",7,"^H",274,"^I",21,"^J",["^K",["^L",["^K",[["~$s","~$idx-key","~$val-key"]]]]],"^M","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^5","~$gadjett.collections/map-with-index","^O",false,"^E","gadjett/collections.cljc","^I",21,"^P",["^K",[["~$s","^2O","^2P"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",274,"^H",274,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["~$s","^2O","^2P"]]]]],"^M","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^C",null,"^D",["^ ","^E","^6","^F",63,"^G",7,"^H",63,"^I",26,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^5","~$gadjett.collections/map-object-with-key","^O",false,"^E","gadjett/collections.cljc","^I",26,"^P",["^K",[["~$f","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",63,"^H",63,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^C",null,"^D",["^ ","^E","^6","^F",459,"^G",8,"^H",459,"^I",19,"^27",true,"^J",["^K",["^L",["^K",[["~$&","^22"]]]]],"^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^22"]]],"^J",["^K",[["~$&","^22"]]],"^R",["^K",[null]]]],"^27",true,"^5","~$gadjett.collections/deep-merge*","^O",true,"^E","gadjett/collections.cljc","^I",19,"^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^22"]]],"^J",["^K",[["~$&","^22"]]],"^R",["^K",[null]]],"^P",[["^K",["^22"]]],"^Q",null,"^R",["^K",[null]],"^G",1,"^F",459,"^H",459,"^S",0,"^T",true,"^J",["^K",[["~$&","^22"]]]],"~$range-till-end",["^ ","^C",null,"^D",["^ ","^E","^6","^F",125,"^G",7,"^H",125,"^I",21,"^J",["^K",["^L",["^K",[["~$&","^2J"]]]]],"^M","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^2J"]]],"^J",["^K",[["~$&","^2J"]]],"^R",["^K",[null]]]],"^5","~$gadjett.collections/range-till-end","^O",true,"^E","gadjett/collections.cljc","^I",21,"^1G",["^ ","^O",true,"^S",0,"^P",[["^K",["^2J"]]],"^J",["^K",[["~$&","^2J"]]],"^R",["^K",[null]]],"^P",[["^K",["^2J"]]],"^Q",null,"^R",["^K",[null]],"^G",1,"^F",125,"^H",125,"^S",0,"^T",true,"^J",["^K",[["~$&","^2J"]]],"^M","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^C",null,"^D",["^ ","^E","^6","^F",238,"^G",7,"^H",238,"^I",21,"^J",["^K",["^L",["^K",[["~$a","~$b"]]]]],"^M","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^5","~$gadjett.collections/nearest-of-seq","^O",false,"^E","gadjett/collections.cljc","^I",21,"^P",["^K",[["~$a","~$b"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",238,"^H",238,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$a","~$b"]]]]],"^M","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^C",null,"^D",["^ ","^E","^6","^F",120,"^G",8,"^H",120,"^I",22,"^27",true,"^J",["^K",["^L",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","~$steps"]]]]],"^1G",["^ ","^O",false,"^S",3,"^P",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]],"^J",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]],"^R",["^K",[null,null,null]]]],"^27",true,"^5","~$gadjett.collections/range-with-end","^O",false,"^E","gadjett/collections.cljc","^I",22,"^1G",["^ ","^O",false,"^S",3,"^P",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]],"^J",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]],"^R",["^K",[null,null,null]]],"^P",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]],"^Q",null,"^R",["^K",[null,null,null]],"^G",1,"^F",120,"^H",120,"^S",3,"^T",true,"^J",["^K",[["^1S"],["^1R","^1S"],["^1R","^1S","^2["]]]],"~$branches-and-leaves",["^ ","^C",null,"^D",["^ ","^E","^6","^F",480,"^G",7,"^H",480,"^I",26,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^5","~$gadjett.collections/branches-and-leaves","^O",false,"^E","gadjett/collections.cljc","^I",26,"^P",["^K",[["~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",480,"^H",480,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$remove-blank-lines",["^ ","^C",null,"^D",["^ ","^E","^6","^F",630,"^G",7,"^H",630,"^I",25,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^5","~$gadjett.collections/remove-blank-lines","^O",false,"^E","gadjett/collections.cljc","^I",25,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",630,"^H",630,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$filter-branches",["^ ","^C",null,"^D",["^ ","^E","^6","^F",494,"^G",7,"^H",494,"^I",22,"^J",["^K",["^L",["^K",[["~$m","~$p"]]]]],"^M","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^5","~$gadjett.collections/filter-branches","^O",false,"^E","gadjett/collections.cljc","^I",22,"^P",["^K",[["~$m","~$p"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",494,"^H",494,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$m","~$p"]]]]],"^M","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$comment?",["^ ","^C",null,"^D",["^ ","^E","^6","^F",593,"^G",8,"^H",593,"^I",16,"^27",true,"^J",["^K",["^L",["^K",[["~$s"]]]]]],"^27",true,"^5","~$gadjett.collections/comment?","^O",false,"^E","gadjett/collections.cljc","^I",16,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",593,"^H",593,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^C",null,"^D",["^ ","^E","^6","^F",506,"^G",7,"^H",506,"^I",20,"^J",["^K",["^L",["^K",[["~$v","~$idx"]]]]],"^M","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^5","~$gadjett.collections/out-of-bound?","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["~$v","^3:"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",506,"^H",506,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$v","^3:"]]]]],"^M","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^C",null,"^D",["^ ","^E","^6","^F",29,"^G",7,"^H",29,"^I",17,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^5","~$gadjett.collections/map-2d-vec","^O",false,"^E","gadjett/collections.cljc","^I",17,"^P",["^K",[["~$f","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",29,"^H",29,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^C",null,"^D",["^ ","^E","^6","^F",324,"^G",7,"^H",324,"^I",25,"^J",["^K",["^L",["^K",[["^17","^18","~$n"]]]]],"^M","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^5","~$gadjett.collections/split-by-predicate","^O",false,"^E","gadjett/collections.cljc","^I",25,"^P",["^K",[["^17","^18","~$n"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",324,"^H",324,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["^17","^18","~$n"]]]]],"^M","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"~$abs",["^ ","^C",null,"^D",["^ ","^E","^6","^F",215,"^G",7,"^H",215,"^I",10,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^5","~$gadjett.collections/abs","^O",false,"^E","gadjett/collections.cljc","^I",10,"^P",["^K",[["~$x"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",215,"^H",215,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$append-cyclic",["^ ","^C",null,"^D",["^ ","^E","^6","^F",145,"^G",7,"^H",145,"^I",20,"^J",["^K",["^L",["^K",[["^1[","~$a"]]]]],"^M","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^5","~$gadjett.collections/append-cyclic","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["^1[","~$a"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",145,"^H",145,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^1[","~$a"]]]]],"^M","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$collify",["^ ","^C",null,"^D",["^ ","^E","^6","^F",532,"^G",7,"^H",532,"^I",14,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^5","~$gadjett.collections/collify","^O",false,"^E","gadjett/collections.cljc","^I",14,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",532,"^H",532,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^C",null,"^D",["^ ","^E","^6","^F",40,"^G",7,"^H",40,"^I",20,"^J",["^K",["^L",["^K",[["^2<","^2=","~$m"]]]]],"^M","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^5","~$gadjett.collections/map-2d-vec-kv","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["^2<","^2=","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",40,"^H",40,"^S",3,"^T",true,"^J",["^K",["^L",["^K",[["^2<","^2=","~$m"]]]]],"^M","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^C",null,"^D",["^ ","^E","^6","^F",183,"^G",7,"^H",183,"^I",18,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^5","~$gadjett.collections/max-and-min","^O",false,"^E","gadjett/collections.cljc","^I",18,"^P",["^K",[["~$x"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",183,"^H",183,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^C",null,"^D",["^ ","^E","^6","^F",400,"^G",7,"^H",400,"^I",15,"^J",["^K",["^L",["^K",[["~$s","~$element"]]]]],"^M","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^5","~$gadjett.collections/index-of","^O",false,"^E","gadjett/collections.cljc","^I",15,"^P",["^K",[["~$s","^3K"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",400,"^H",400,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$s","^3K"]]]]],"^M","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^C",null,"^D",["^ ","^E","^6","^F",226,"^G",7,"^H",226,"^I",20,"^J",["^K",["^L",["^K",[["~$ss","~$x"]]]]],"^M","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^5","~$gadjett.collections/nearest-of-ss","^O",false,"^E","gadjett/collections.cljc","^I",20,"^P",["^K",[["^3N","~$x"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",226,"^H",226,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^3N","~$x"]]]]],"^M","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^C",null,"^D",["^ ","^E","^6","^F",84,"^G",7,"^H",84,"^I",28,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^5","~$gadjett.collections/map-reverse-hierarchy","^O",false,"^E","gadjett/collections.cljc","^I",28,"^P",["^K",[["~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",84,"^H",84,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$m"]]]]],"^M","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^C",null,"^D",["^ ","^E","^6","^F",596,"^G",7,"^H",596,"^I",29,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^5","~$gadjett.collections/remove-ending-comments","^O",false,"^E","gadjett/collections.cljc","^I",29,"^P",["^K",[["~$s"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",596,"^H",596,"^S",1,"^T",true,"^J",["^K",["^L",["^K",[["~$s"]]]]],"^M","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^C",null,"^D",["^ ","^E","^6","^F",52,"^G",7,"^H",52,"^I",17,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^5","~$gadjett.collections/map-object","^O",false,"^E","gadjett/collections.cljc","^I",17,"^P",["^K",[["~$f","~$m"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",52,"^H",52,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["~$f","~$m"]]]]],"^M","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$my-replace",["^ ","^C",null,"^D",["^ ","^E","^6","^F",578,"^G",7,"^H",578,"^I",17,"^J",["^K",["^L",["^K",[["^28","~$form"]]]]],"^M","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^5","~$gadjett.collections/my-replace","^O",false,"^E","gadjett/collections.cljc","^I",17,"^P",["^K",[["^28","^3W"]]],"^Q",null,"^R",["^K",[null,null]],"^G",1,"^F",578,"^H",578,"^S",2,"^T",true,"^J",["^K",["^L",["^K",[["^28","^3W"]]]]],"^M","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^3W","^3:","~$&","~$x","^25","^B","^U","^1S","^W","^2:","^10","^16","^34","^3U","^2<","^29","^1:","~:max-elements-in-coll","^36","^1<","^2F","^2H","~$p","^6","^3=","^1W","~$a","^1=","^1@","^1I","^2Q","^27","~:else","^2U","^1K","^2W","^2J","^1N","^2Y","^30","^3E","^1E","^3G","^3I","~:max-chars-in-str","~:ns","^1Q","^5","^12","^1U","^O","^1B","~:first-val","^1[","^E","~$v","^3O","^3S","^3Q","^2K","^I","^1G","^3X","~:branches","^3K","^1X","^1Z","^21","^2P","^24","^1L","^18","^3;","^P","^11","^26","^2;","^2M","^3A","^2?","^R","^2S","^2L","^2A","^G","^2C","^Z","^X","^1?","^2E","^2G","~$n","~$m","^2[","^3L","^1C","^2I","^2N","^1J","^1F","~:leaves","^1R","^17","^2R","^2T","^F","^2V","^2X","^2Z","^38","~:max-val","^V","^31","^[","~$s","^14","^2O","^3?","^33","~$k","^19","^1;","^3C","^H","^35","^1Y","^20","^37","^23","^32","^13","^39","^22","^S","^28","^3<","^1H","^2>","^3>","^3@","^1V","^2@","^J","^3B","^1D","^2B","^1M","^1O","^2D","^M","^2=","^Y","^3D","^1P","^3F","^3H","^N","^1T","^1>","^3N","~$b","~:test","^3J","^1A","^3M","^3P","^3R","^3T","~$d","~$f","^3V"]],"~:order",["^1P","^43","^5","^E","^I","^G","^F","^H","^J","^M","^48","^6","^1E","^[","^W","^X","^Y","^Z","^1M","^1K","^1L","^3=","^3<","~$f","~$m","^3G","^3F","^2<","^2=","^3U","^3T","^2S","^2R","^2>","^2;","^3Q","^3P","^25","^24","~$x","^V","^U","~$s","^30","^27","^1G","^2Z","^O","^S","^P","^R","^1S","^1R","^2[","^2W","^2V","^2J","~$&","^3C","^3B","^1[","~$a","^1O","^1N","^17","~$k","~$v","~$n","^3I","^3H","^2D","^2C","^1J","^1I","^3A","^3@","^3O","^3M","^3N","^2Y","^2X","~$b","^20","^1Z","^1;","^1:","^2Q","^2N","^2O","^2P","^14","^10","^11","^12","^13","^1H","^1@","^1A","^1B","^1F","^1C","^1D","^44","^47","^3?","^3>","^18","^19","^16","~$d","^1?","^1<","^1=","^1>","^1T","^1Q","^3L","^3J","^3K","^2B","^2A","^2@","^2?","^N","^B","^2H","^2G","^2U","^2T","^22","^23","^21","^45","^46","^32","^31","^36","^35","~$p","^3;","^39","^3:","^2F","^2E","^3E","^3D","^1W","^1U","^1V","^2:","^26","^28","^29","^3X","^3V","^3W","^38","^37","^3S","^3R","^1Y","^1X","^34","^33","^2M","^2I","^2K","^2L","^40","^42","^41"]],"^M",null]