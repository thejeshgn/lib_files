["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$ct","~$clojure.test.check.clojure-test","~$rose","~$clojure.test.check.rose-tree","~$clojure.test.check.impl","^=","^<","^<","~$clojure.test.check.generators","^>","~$gen","^>","~$clojure.test.check.random","^@","^:","^:","~$random","^@"],"~:uses",["^ ","~$exception-like?","^=","~$get-current-time-millis","^="],"~:defs",["^ ","~$complete",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^6","~:line",27,"~:column",8,"~:end-line",27,"~:end-column",16,"~:private",true,"~:arglists",["~#list",["~$quote",["^P",[["~$property","~$num-trials","~$seed"]]]]]],"^N",true,"^5","~$clojure.test.check/complete","~:variadic",false,"^I","clojure/test/check.cljc","^M",16,"~:method-params",["^P",[["^R","^S","^T"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^K",1,"^J",27,"^L",27,"~:max-fixed-arity",3,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["^R","^S","^T"]]]]]],"~$shrink-loop",["^ ","^G",null,"^H",["^ ","^I","^6","^J",79,"^K",8,"^L",79,"^M",19,"^N",true,"^O",["^P",["^Q",["^P",[["~$rose-tree"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"^N",true,"^5","~$clojure.test.check/shrink-loop","^V",false,"^I","clojure/test/check.cljc","^M",19,"^W",["^P",[["^11"]]],"^X",null,"^Y",["^P",[null,null]],"^K",1,"^J",79,"^L",79,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^11"]]]]],"^12","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"~$make-rng",["^ ","^G",null,"^H",["^ ","^I","^6","^J",20,"^K",8,"^L",20,"^M",16,"^N",true,"^O",["^P",["^Q",["^P",[["^T"]]]]]],"^N",true,"^5","~$clojure.test.check/make-rng","^V",false,"^I","clojure/test/check.cljc","^M",16,"^W",["^P",[["^T"]]],"^X",null,"^Y",["^P",[null,null]],"^K",1,"^J",20,"^L",20,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^T"]]]]]],"~$not-falsey-or-exception?",["^ ","^G",null,"^H",["^ ","^I","^6","^J",32,"^K",8,"^L",32,"^M",32,"^N",true,"^O",["^P",["^Q",["^P",[["~$value"]]]]],"^12","True if the value is not falsy or an exception"],"^N",true,"^5","~$clojure.test.check/not-falsey-or-exception?","^V",false,"^I","clojure/test/check.cljc","^M",32,"^W",["^P",[["^17"]]],"^X",null,"^Y",["^P",[null,null]],"^K",1,"^J",32,"^L",32,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^17"]]]]],"^12","True if the value is not falsy or an exception"],"~$failure",["^ ","^G",null,"^H",["^ ","^I","^6","^J",112,"^K",8,"^L",112,"^M",15,"^N",true,"^O",["^P",["^Q",["^P",[["^R","~$failing-rose-tree","~$trial-number","~$size","^T"]]]]]],"^N",true,"^5","~$clojure.test.check/failure","^V",false,"^I","clojure/test/check.cljc","^M",15,"^W",["^P",[["^R","^1:","^1;","^1<","^T"]]],"^X",null,"^Y",["^P",[null,null]],"^K",1,"^J",112,"^L",112,"^Z",5,"^[",true,"^O",["^P",["^Q",["^P",[["^R","^1:","^1;","^1<","^T"]]]]]],"~$smallest-shrink",["^ ","^G",null,"^H",["^ ","^I","^6","^J",72,"^K",8,"^L",72,"^M",23,"^N",true,"^O",["^P",["^Q",["^P",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^N",true,"^5","~$clojure.test.check/smallest-shrink","^V",false,"^I","clojure/test/check.cljc","^M",23,"^W",["^P",[["^1?","^1@","^1A"]]],"^X",null,"^Y",["^P",[null,null]],"^K",1,"^J",72,"^L",72,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1?","^1@","^1A"]]]]]],"~$quick-check",["^ ","^G",null,"^H",["^ ","^I","^6","^J",37,"^K",7,"^L",37,"^M",18,"^O",["^P",["^Q",["^P",[["~$num-tests","^R","~$&",["^ ","~:or",["^ ","~$max-size",200],"~:keys",["^T","^1F"]]]]]]],"^12","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  ","~:top-fn",["^ ","^V",true,"^Z",2,"^W",[["^P",["^1D","^R",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^O",["^P",[["^1D","^R","~$&",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^Y",["^P",[null]]]],"^5","~$clojure.test.check/quick-check","^V",true,"^I","clojure/test/check.cljc","^M",18,"^1H",["^ ","^V",true,"^Z",2,"^W",[["^P",["^1D","^R",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^O",["^P",[["^1D","^R","~$&",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^Y",["^P",[null]]],"^W",[["^P",["^1D","^R",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^X",null,"^Y",["^P",[null]],"^K",1,"^J",37,"^L",37,"^Z",2,"^[",true,"^O",["^P",[["^1D","^R","~$&",["^ ","^1E",["^ ","^1F",200],"^1G",["^T","^1F"]]]]],"^12","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  "]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~$&","^11","^F","^10","^14","~:shrunk","^18","^1B","^1I","~:total-nodes-visited","^N","^1:","~:ns","^5","^15","^V","^1E","^U","^I","~:num-tests","^M","^1H","^13","^1?","~:max-size","^W","^16","^19","^1>","^Y","~:seed","^R","^1C","^K","^6","^17","^1D","~:fail","^1G","^J","^1F","~:result","^1=","~:smallest","~:declared","~:failing-size","^T","^1<","^L","^1;","~:depth","^Z","^O","^12","^1A","~:test","^S","^1@"]],"~:order",["^13","^1P","^5","^I","^M","^K","^J","^1W","^L","^O","^12","^1Z","^6","^10","^1=","^19","^15","^N","^14","^T","^1Q","^1S","^1U","^U","^F","^R","^S","^18","^16","^17","^1I","^1H","^1C","^V","^Z","^W","^Y","^1D","^1E","^1G","^1F","~$&","^1R","^1M","^1O","^1V","^1Y","^1B","^1>","^1?","^1@","^1A","^11","^1N","^1T","^1X","^1:","^1;","^1<"]],"^12",null]