{"version":3,"file":"420.bundle.js","mappings":"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","sources":["./app/client/models/SearchModel.ts?","./app/client/ui2018/search.ts?"],"sourcesContent":["// tslint:disable:no-console\n// TODO: Add documentation and clean up log statements.\n\nimport {GristDoc} from 'app/client/components/GristDoc';\nimport {PageRec, ViewFieldRec, ViewSectionRec} from 'app/client/models/DocModel';\nimport {reportError} from 'app/client/models/errors';\nimport {delay} from 'app/common/delay';\nimport {IDocPage} from 'app/common/gristUrls';\nimport {nativeCompare, waitObs} from 'app/common/gutil';\nimport {TableData} from 'app/common/TableData';\nimport {BaseFormatter} from 'app/common/ValueFormatter';\nimport { makeT } from 'app/client/lib/localization';\nimport {CursorPos} from 'app/plugin/GristAPI';\nimport {Computed, Disposable, Observable} from 'grainjs';\nimport debounce = require('lodash/debounce');\n\nconst t = makeT('SearchModel');\n\n/**\n * SearchModel used to maintain the state of the search UI.\n */\nexport interface SearchModel {\n  value: Observable<string>;       // string in the search input\n  isOpen: Observable<boolean>;     // indicates whether the search bar is expanded to show the input\n  noMatch: Observable<boolean>;    // indicates if there are no search matches\n  isEmpty: Observable<boolean>;     // indicates whether the value is empty\n  isRunning: Observable<boolean>;  // indicates that matching is in progress\n  multiPage: Observable<boolean>;   // if true will search across all pages\n  allLabel: Observable<string>;   // label to show instead of default 'Search all pages'\n\n  findNext(): Promise<void>;       // find next match\n  findPrev(): Promise<void>;       // find previous match\n}\n\ninterface SearchPosition {\n  pageIndex: number;\n  sectionIndex: number;\n  rowIndex: number;\n  fieldIndex: number;\n}\n\n/**\n * Stepper is an helper class that is used to implement stepping through all the cells of a\n * document. Fields belongs to rows, rows belongs to section and sections to pages. So this is four\n * steppers that must be used together, one for each level (field, rows, section and pages). When a\n * stepper reaches the end of its array, this is the `nextArrayFunc` callback, passed to the\n * `next()`, that is responsible for both taking a step at the higher level and updating the\n * stepper's array.\n */\nclass Stepper<T> {\n  public array: ReadonlyArray<T> = [];\n  public index: number = 0;\n\n  public inRange() {\n    return this.index >= 0 && this.index < this.array.length;\n  }\n\n  // Doing await at every step adds a ton of overhead; we can optimize by returning and waiting on\n  // Promises only when needed.\n  public next(step: number, nextArrayFunc: () => Promise<void>|void): Promise<void>|void {\n    this.index += step;\n    if (!this.inRange()) {\n      // If index reached the end of the array, take a step at a higher level to get a new array.\n      // For efficiency, only wait asynchronously if the callback returned a promise.\n      const p = nextArrayFunc();\n      if (p) {\n        return p.then(() => this.setStart(step));\n      } else {\n        this.setStart(step);\n      }\n    }\n  }\n\n  public setStart(step: number) {\n    this.index = step > 0 ? 0 : this.array.length - 1;\n  }\n\n  public get value(): T { return this.array[this.index]; }\n}\n\n/**\n * Interface that represents an ongoing search job which stops on the first match found.\n */\ninterface IFinder {\n  matchFound: boolean;             // true if a match was found\n  startPosition: SearchPosition;   // position at which to stop searching for a new match\n  abort(): void;                   // abort current search\n  matchNext(step: number): Promise<void>;      // next match\n  nextField(step: number): Promise<void>|void; // move the current position\n  getCurrentPosition(): SearchPosition;        // get the current position\n}\n\n// A callback to opening a page: useful to switch to next page during an ongoing search.\ntype DocPageOpener = (viewId: IDocPage) => Promise<void>;\n\n// To support Raw Data Views we will introduce a 'wrapped' page abstraction. Raw data\n// page is not a true page (it doesn't have a record), this will allow as to treat a raw view section\n// as if it were a PageRec.\ninterface ISearchablePageRec {\n  viewSections(): ViewSectionRec[];\n  activeSectionId(): number;\n  getViewId(): IDocPage;\n  openPage(): Promise<void>;\n}\n\nclass RawSectionWrapper implements ISearchablePageRec {\n  constructor(private _section: ViewSectionRec) {\n\n  }\n  public viewSections(): ViewSectionRec[] {\n    return [this._section];\n  }\n\n  public activeSectionId() {\n    return this._section.id.peek();\n  }\n\n  public getViewId(): IDocPage {\n    return 'data';\n  }\n\n  public async openPage() {\n    this._section.view.peek().activeSectionId(this._section.getRowId());\n    await waitObs(this._section.viewInstance);\n    await this._section.viewInstance.peek()?.getLoadingDonePromise();\n  }\n}\n\nclass PageRecWrapper implements ISearchablePageRec {\n  constructor(private _page: PageRec, private _opener: DocPageOpener) {\n\n  }\n  public viewSections(): ViewSectionRec[] {\n    const sections = this._page.view.peek().viewSections.peek().peek();\n    const collapsed = new Set(this._page.view.peek().activeCollapsedSections.peek());\n    const activeSectionId = this._page.view.peek().activeSectionId.peek();\n    // If active section is collapsed, it means it is rendered in the popup, so narrow\n    // down the search to only it.\n    const inPopup = collapsed.has(activeSectionId);\n    if (inPopup) {\n      return sections.filter((s) => s.getRowId() === activeSectionId);\n    }\n    return sections.filter((s) => !collapsed.has(s.getRowId()));\n  }\n\n  public activeSectionId() {\n    return this._page.view.peek().activeSectionId.peek();\n  }\n\n  public getViewId() {\n    return this._page.view.peek().getRowId();\n  }\n\n  public openPage() {\n    return this._opener(this.getViewId());\n  }\n}\n\n//activeSectionId\n\n/**\n * An implementation of an IFinder.\n */\nclass FinderImpl implements IFinder {\n  public matchFound = false;\n  public startPosition: SearchPosition;\n\n  private _searchRegexp: RegExp;\n  private _pageStepper = new Stepper<ISearchablePageRec>();\n  private _sectionStepper = new Stepper<ViewSectionRec>();\n  private _sectionTableData: TableData;\n  private _rowStepper = new Stepper<number>();\n  private _fieldStepper = new Stepper<ViewFieldRec>();\n  private _fieldFormatters: [ViewFieldRec, BaseFormatter][];\n  private _pagesSwitched: number = 0;\n  private _aborted = false;\n  private _clearCursorHighlight: (() => void)|undefined;\n\n  constructor(private _gristDoc: GristDoc, value: string, private _openDocPageCB: DocPageOpener,\n              public multiPage: Observable<boolean>) {\n    this._searchRegexp = makeRegexp(value);\n  }\n\n  public abort() {\n    this._aborted = true;\n    if (this._clearCursorHighlight) { this._clearCursorHighlight(); }\n  }\n\n  public getCurrentPosition(): SearchPosition {\n    return {\n      pageIndex: this._pageStepper.index,\n      sectionIndex: this._sectionStepper.index,\n      rowIndex: this._rowStepper.index,\n      fieldIndex: this._fieldStepper.index,\n    };\n  }\n\n  // Initialize the steppers. Returns false if anything goes wrong.\n  public async init(): Promise<boolean> {\n    // If we are on a raw view page, pretend that we are looking at true pages.\n    if ('data' === this._gristDoc.activeViewId.get()) {\n      // Get all raw sections.\n      const rawSections = this._gristDoc.docModel.visibleTables.peek()\n                              // sort in order that is the same as on the raw data list page,\n                              .sort((a, b) => nativeCompare(a.tableNameDef.peek(), b.tableNameDef.peek()))\n                              // get rawViewSection,\n                              .map(table => table.rawViewSection.peek())\n                              // and test if it isn't an empty record.\n                              .filter(s => Boolean(s.id.peek()));\n      // Pretend that those are pages.\n      this._pageStepper.array = rawSections.map(r => new RawSectionWrapper(r));\n      // Find currently selected one (by comparing to active section id)\n      this._pageStepper.index = rawSections.findIndex(s =>\n        s.getRowId() === this._gristDoc.viewModel.activeSectionId.peek());\n      // If we are at listing, where no section is active open the first page. Otherwise, search will fail.\n      if (this._pageStepper.index < 0) {\n        this._pageStepper.index = 0;\n        await this._pageStepper.value.openPage();\n      }\n    } else {\n      // Else read all visible pages.\n      const pages = this._gristDoc.docModel.visibleDocPages.peek();\n      this._pageStepper.array = pages.map(p => new PageRecWrapper(p, this._openDocPageCB));\n      this._pageStepper.index = pages.findIndex(page => page.viewRef.peek() === this._gristDoc.activeViewId.get());\n      if (this._pageStepper.index < 0) { return false; }\n    }\n\n    const sections = this._pageStepper.value.viewSections();\n    this._sectionStepper.array = sections;\n    this._sectionStepper.index = sections.findIndex(s => s.getRowId() === this._pageStepper.value.activeSectionId());\n    if (this._sectionStepper.index < 0) { return false; }\n\n    this._initNewSectionShown();\n\n    // Find the current cursor position in the current section.\n    const viewInstance = this._sectionStepper.value.viewInstance.peek()!;\n    const pos = viewInstance.cursor.getCursorPos();\n    this._rowStepper.index = pos.rowIndex!;\n    this._fieldStepper.index = pos.fieldIndex!;\n    return true;\n  }\n\n  public async matchNext(step: number): Promise<void> {\n    let count = 0;\n    let lastBreak = Date.now();\n\n    this._pagesSwitched = 0;\n\n    while (!this._matches() || ((await this._loadSection(step)) && !this._matches())) {\n\n      // If search was aborted, simply returns.\n      if (this._aborted) { return; }\n\n      // To avoid hogging the CPU for too long, check time periodically, and if we've been running\n      // for long enough, take a brief break. We choose a 5ms break every 20ms; and only check\n      // time every 100 iterations, to avoid excessive overhead purely due to time checks.\n      if ((++count) % 100 === 0 && Date.now() >= lastBreak + 20) {\n        await delay(5);\n        lastBreak = Date.now();\n      }\n\n      const p = this.nextField(step);\n      if (p) { await p; }\n\n      // Detect when we get back to the start position; this is where we break on no match.\n      if (this._isCurrentPosition(this.startPosition) && !this._matches()) {\n        console.log(\"SearchBar: reached start position without finding anything\");\n        this.matchFound = false;\n        return;\n      }\n\n      // A fail-safe to prevent certain bugs from causing infinite loops; break also if we scan\n      // through pages too many times.\n      // TODO: test it by disabling the check above.\n      if (this._pagesSwitched > this._pageStepper.array.length) {\n        console.log(\"SearchBar: aborting search due to too many page switches\");\n        this.matchFound = false;\n        return;\n      }\n    }\n    console.log(\"SearchBar: found a match at %s\", JSON.stringify(this.getCurrentPosition()));\n    this.matchFound = true;\n    await this._highlight();\n  }\n\n  public nextField(step: number): Promise<void>|void {\n    return this._fieldStepper.next(step, () => this._nextRow(step));\n  }\n\n  private _nextRow(step: number) {\n    return this._rowStepper.next(step, () => this._nextSection(step));\n  }\n\n  private async _nextSection(step: number) {\n    // Switching sections is rare enough that we don't worry about optimizing away `await` calls.\n    await this._sectionStepper.next(step, () => this._nextPage(step));\n    await this._initNewSectionAny();\n  }\n\n    // TODO There are issues with filtering. A section may have filters applied, and it may be\n    // auto-filtered (linked sections). If a tab is shown, we have the filtered list of rowIds; if\n    // the tab is not shown, it takes work to apply explicit filters. For linked sections, the\n    // sensible behavior seems to scan through ALL values, then once a match is found, set the\n    // cursor that determines the linking to include the matched row. And even that may not always\n    // be possible. So this is an open question.\n\n  private _initNewSectionCommon() {\n    const section = this._sectionStepper.value;\n    const tableModel = this._gristDoc.getTableModel(section.table.peek().tableId.peek());\n    this._sectionTableData = tableModel.tableData;\n\n    this._fieldStepper.array = section.viewFields().peek();\n    this._initFormatters();\n    return tableModel;\n  }\n\n  private _initNewSectionShown() {\n    this._initNewSectionCommon();\n    const viewInstance = this._sectionStepper.value.viewInstance.peek()!;\n    const skip = ['chart'].includes(this._sectionStepper.value.parentKey.peek());\n    this._rowStepper.array = skip ? [] : viewInstance.sortedRows.getKoArray().peek() as number[];\n  }\n\n  private async _initNewSectionAny() {\n    const tableModel = this._initNewSectionCommon();\n\n    const viewInstance = this._sectionStepper.value.viewInstance.peek();\n    const skip = ['chart'].includes(this._sectionStepper.value.parentKey.peek());\n    if (skip) {\n      this._rowStepper.array = [];\n    } else if (viewInstance) {\n      this._rowStepper.array = viewInstance.sortedRows.getKoArray().peek() as number[];\n    } else {\n      // If we are searching through another page (not currently loaded), we will NOT have a\n      // viewInstance, but we use the unsorted unfiltered row list, and if we find a match, the\n      // _loadSection() method will load the page and we'll repeat the search with a viewInstance.\n      await tableModel.fetch();\n      this._rowStepper.array = this._sectionTableData.getRowIds();\n    }\n  }\n\n  private async _nextPage(step: number) {\n    if (!this.multiPage.get()) { return; }\n    await this._pageStepper.next(step, () => undefined);\n    this._pagesSwitched++;\n\n    const view = this._pageStepper.value;\n    this._sectionStepper.array = view.viewSections();\n  }\n\n  private _initFormatters() {\n    this._fieldFormatters = this._fieldStepper.array.map(f => [f, f.formatter.peek()]);\n  }\n\n  private _matches(): boolean {\n    if (this._pageStepper.index < 0 || this._sectionStepper.index < 0 ||\n        this._rowStepper.index < 0 || this._fieldStepper.index < 0) {\n      console.warn(\"match outside\");\n      return false;\n    }\n    const field = this._fieldStepper.value;\n    let formatter = this._fieldFormatters[this._fieldStepper.index];\n    // When fields are removed during search (or reordered) we need to update\n    // formatters we retrieved on init.\n    if (!formatter || formatter[0 /* field */] !== field) {\n      this._initFormatters();\n      formatter = this._fieldFormatters[this._fieldStepper.index];\n    }\n    const rowId = this._rowStepper.value;\n    const displayCol = field.displayColModel.peek();\n\n    const value = this._sectionTableData.getValue(rowId, displayCol.colId.peek());\n\n    // TODO: Note that formatting dates is now the bulk of the performance cost.\n    const text = formatter[1  /* formatter */].formatAny(value);\n    return this._searchRegexp.test(text);\n  }\n\n  private async _loadSection(step: number): Promise<boolean> {\n    // If we found a match in a section for which we don't have a valid BaseView instance, we need\n    // to load the BaseView and start searching the section again, since the match we found does\n    // not take into account sort or filters. So we switch to the right page, wait for the\n    // viewInstance to be created, reset the section info, and return true to continue searching.\n    const section = this._sectionStepper.value;\n    if (!section.viewInstance.peek()) {\n      const view = this._pageStepper.value;\n      if (this._aborted) { return false; }\n      await view.openPage();\n      console.log(\"SearchBar: loading view %s section %s\", view.getViewId(), section.getRowId());\n      const viewInstance: any = await waitObs(section.viewInstance);\n      await viewInstance.getLoadingDonePromise();\n      this._initNewSectionShown();\n      this._rowStepper.setStart(step);\n      this._fieldStepper.setStart(step);\n      console.log(\"SearchBar: loaded view %s section %s\", view.getViewId(), section.getRowId());\n      return true;\n    }\n    return false;\n  }\n\n  // Highlights the cell at the current position.\n  private async _highlight() {\n    if (this._aborted) { return; }\n\n    const section = this._sectionStepper.value;\n    const sectionId = section.getRowId();\n    const cursorPos: CursorPos = {\n      sectionId,\n      rowId: this._rowStepper.value,\n      fieldIndex: this._fieldStepper.index,\n    };\n    await this._gristDoc.recursiveMoveToCursorPos(cursorPos, true).catch(reportError);\n    if (this._aborted) { return; }\n\n    // Highlight the selected cursor, after giving it a chance to update. We find the cursor in\n    // this ad-hoc way rather than use observables, to avoid the overhead of *every* cell\n    // depending on an additional observable.\n    await delay(0);\n    const viewInstance = (await waitObs(section.viewInstance))!;\n    await viewInstance.getLoadingDonePromise();\n    if (this._aborted) { return; }\n    // Make sure we are at good place. This is important when the cursor\n    // was already in a matched record, but the record was scrolled away.\n    viewInstance.scrollToCursor(true).catch(reportError);\n\n    const cursor = viewInstance.viewPane.querySelector('.selected_cursor');\n    if (cursor) {\n      cursor.classList.add('search-match');\n      this._clearCursorHighlight = () => {\n        cursor.classList.remove('search-match');\n        clearTimeout(timeout);\n        this._clearCursorHighlight = undefined;\n      };\n      const timeout = setTimeout(this._clearCursorHighlight, 20);\n    }\n  }\n\n  private _isCurrentPosition(pos: SearchPosition): boolean {\n    return (\n      this._pageStepper.index === pos.pageIndex &&\n        this._sectionStepper.index === pos.sectionIndex &&\n        this._rowStepper.index === pos.rowIndex &&\n        this._fieldStepper.index === pos.fieldIndex\n    );\n  }\n}\n\n/**\n * Implementation of SearchModel used to construct the search UI.\n */\nexport class SearchModelImpl extends Disposable implements SearchModel {\n  public readonly value = Observable.create(this, '');\n  public readonly isOpen = Observable.create(this, false);\n  public readonly isRunning = Observable.create(this, false);\n  public readonly noMatch = Observable.create(this, true);\n  public readonly isEmpty = Observable.create(this, true);\n  public readonly multiPage = Observable.create(this, false);\n  public readonly allLabel: Computed<string>;\n\n  private _isRestartNeeded = false;\n  private _finder: IFinder|null = null;\n\n  constructor(private _gristDoc: GristDoc) {\n    super();\n\n    // Listen to input value changes (debounced) to activate searching.\n    const findFirst = debounce((_value: string) => this._findFirst(_value), 100);\n    this.autoDispose(this.value.addListener(v => { this.isRunning.set(true); void findFirst(v); }));\n\n    // Set this.noMatch to false when multiPage gets turned ON.\n    this.autoDispose(this.multiPage.addListener(v => { if (v) { this.noMatch.set(false); } }));\n\n    this.allLabel = Computed.create(this, use => use(this._gristDoc.activeViewId) === 'data' ?\n      t('Search all tables') : t('Search all pages'));\n\n    // Schedule a search restart when user changes pages (otherwise search would resume from the\n    // previous page that is not shown anymore). Also revert noMatch flag when in single page mode.\n    this.autoDispose(this._gristDoc.activeViewId.addListener(() => {\n      if (!this.multiPage.get()) { this.noMatch.set(false); }\n      this._isRestartNeeded = true;\n    }));\n\n    // On Raw data view, whenever table is closed (so activeSectionId = 0), restart search.\n    this.autoDispose(this._gristDoc.viewModel.activeSectionId.subscribe((sectionId) => {\n      if (this._gristDoc.activeViewId.get() === 'data' && sectionId === 0) {\n        this._isRestartNeeded = true;\n        this.noMatch.set(false);\n      }\n    }));\n  }\n\n  public async findNext() {\n    if (this.isRunning.get() || this.noMatch.get()) { return; }\n    if (this._isRestartNeeded) { return this._findFirst(this.value.get()); }\n    await this._run(async (finder) => {\n      await finder.nextField(1);\n      await finder.matchNext(1);\n    });\n  }\n\n  public async findPrev() {\n    if (this.isRunning.get() || this.noMatch.get()) { return; }\n    if (this._isRestartNeeded) { return this._findFirst(this.value.get()); }\n    await this._run(async (finder) => {\n      await finder.nextField(-1);\n      await finder.matchNext(-1);\n    });\n  }\n\n  private async _findFirst(value: string) {\n    this._isRestartNeeded = false;\n    this.isEmpty.set(!value);\n    await this._updateFinder(value);\n    if (!value || !this._finder) { this.noMatch.set(true); return; }\n    await this._run(async (finder) => {\n      await finder.matchNext(1);\n    });\n  }\n\n  private async _updateFinder(value: string) {\n    if (this._finder) { this._finder.abort(); }\n    const impl = new FinderImpl(this._gristDoc, value, this._openDocPage.bind(this), this.multiPage);\n    const isValid = await impl.init();\n    this._finder = isValid ? impl : null;\n  }\n\n  // Internal helper that runs cb, passing it the current `this._finder` as first argument and sets\n  // this.isRunning to true until the call resolves. It also takes care of updating this.noMatch.\n  private async _run(cb: (finder: IFinder) => Promise<void>) {\n\n    const finder = this._finder;\n    if (!finder) { throw new Error(\"SearchModel: finder is not defined\"); }\n\n    try {\n      this.isRunning.set(true);\n      finder.startPosition = finder.getCurrentPosition();\n      await cb(finder);\n    } finally {\n      this.isRunning.set(false);\n      this.noMatch.set(!finder.matchFound);\n    }\n  }\n\n  // Opens doc page without triggering a restart.\n  private async _openDocPage(viewId: IDocPage) {\n    await this._gristDoc.openDocPage(viewId);\n    this._isRestartNeeded = false;\n  }\n}\n\nfunction makeRegexp(value: string) {\n  // From https://stackoverflow.com/a/3561711/328565\n  const escaped = value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  return new RegExp(escaped, 'i');\n}\n","/**\n * Search icon that expands to a search bar and collapse on 'x' or blur.\n * Takes a `SearchModel` that controls the search behavior.\n */\nimport { allCommands, createGroup } from 'app/client/components/commands';\nimport { makeT } from 'app/client/lib/localization';\nimport { reportError } from 'app/client/models/AppModel';\nimport { SearchModel } from 'app/client/models/SearchModel';\nimport { hoverTooltip } from 'app/client/ui/tooltips';\nimport { cssHoverCircle, cssTopBarBtn } from 'app/client/ui/TopBarCss';\nimport { labeledSquareCheckbox } from 'app/client/ui2018/checkbox';\nimport { mediaSmall, theme, vars } from 'app/client/ui2018/cssVars';\nimport { icon } from 'app/client/ui2018/icons';\nimport { dom, input, styled } from 'grainjs';\nimport { noTestId, TestId } from 'grainjs';\nimport debounce = require('lodash/debounce');\n\nexport * from 'app/client/models/SearchModel';\n\nconst t = makeT('search');\n\nconst EXPAND_TIME = .5;\n\nconst searchWrapper = styled('div', `\n  display: flex;\n  flex: initial;\n  align-items: center;\n  box-sizing: border-box;\n  border: 1px solid transparent;\n  padding: 0px 16px;\n  width: 50px;\n  height: 100%;\n  max-height: 50px;\n  transition: width 0.4s;\n  position: relative;\n  &-expand {\n    width: 100% !important;\n    border: 1px solid ${theme.searchBorder};\n  }\n  @media ${mediaSmall} {\n    & {\n      width: 32px;\n      padding: 0px;\n    }\n  }\n`);\n\nconst expandedSearch = styled('div', `\n  display: flex;\n  flex-grow: 0;\n  align-items: center;\n  width: 0;\n  opacity: 0;\n  align-self: stretch;\n  transition: width ${EXPAND_TIME}s, opacity ${EXPAND_TIME / 2}s ${EXPAND_TIME / 2}s;\n  .${searchWrapper.className}-expand > & {\n    width: auto;\n    flex-grow: 1;\n    opacity: 1;\n  }\n`);\n\nconst searchInput = styled(input, `\n  background-color: ${theme.topHeaderBg};\n  color: ${theme.inputFg};\n  outline: none;\n  border: none;\n  margin: 0;\n  padding: 0;\n  padding-left: 4px;\n  box-sizing: border-box;\n  align-self: stretch;\n  width: 0;\n  transition: width ${EXPAND_TIME}s;\n  .${searchWrapper.className}-expand & {\n    width: 100%;\n  }\n  &::placeholder {\n    color: ${theme.inputPlaceholderFg};\n  }\n`);\n\nconst cssArrowBtn = styled('div', `\n  font-size: 14px;\n  padding: 3px;\n  cursor: pointer;\n  margin: 2px 4px;\n  visibility: hidden;\n  width: 24px;\n  height: 24px;\n  background-color: ${theme.searchPrevNextButtonBg};\n  --icon-color: ${theme.searchPrevNextButtonFg};\n  border-radius: 3px;\n  text-align: center;\n  display: flex;\n  align-items: center;\n\n  .${searchWrapper.className}-expand & {\n    visibility: visible;\n  }\n`);\n\nconst cssCloseBtn = styled(icon, `\n  cursor: pointer;\n  background-color: ${theme.controlFg};\n  margin-left: 4px;\n  flex-shrink: 0;\n`);\n\nconst cssLabel = styled('span', `\n  font-size: ${vars.smallFontSize};\n  color: ${theme.lightText};\n  white-space: nowrap;\n  margin-right: 12px;\n`);\n\nconst cssOptions = styled('div', `\n  background: ${theme.topHeaderBg};\n  position: absolute;\n  right: 0;\n  top: 48px;\n  z-index: 1;\n  padding: 2px 4px;\n  overflow: hidden;\n  white-space: nowrap;\n`);\n\nconst cssShortcut = styled('span', `\n  color: ${theme.lightText};\n`);\n\nexport function searchBar(model: SearchModel, testId: TestId = noTestId) {\n  let keepExpanded = false;\n\n  const focusAndSelect = () => { inputElem.focus(); inputElem.select(); };\n\n  const commandGroup = createGroup({\n    find: focusAndSelect,\n    // On Mac, Firefox has a default behaviour witch causes to close the search bar on Cmd+g and\n    // Cmd+shirt+G. Returning false is a Mousetrap convenience which prevents that.\n    findNext: () => { model.findNext().catch(reportError); return false; },\n    findPrev: () => { model.findPrev().catch(reportError); return false; },\n  }, null, true);\n\n  const toggleMenu = debounce((_value?: boolean) => {\n    model.isOpen.set(_value === undefined ? !model.isOpen.get() : _value);\n  }, 100);\n  const inputElem: HTMLInputElement = searchInput(model.value, {onInput: true},\n    {type: 'text', placeholder: t(\"Search in document\")},\n    dom.on('blur', () => (\n      keepExpanded ?\n        setTimeout(() => inputElem.focus(), 0) :\n        toggleMenu(false)\n    )),\n    dom.onKeyDown({\n      Enter: (ev) => ev.shiftKey ? model.findPrev() : model.findNext(),\n      Escape: () => { keepExpanded = false; toggleMenu(false); },\n      // Catch both Tab and Shift+Tab to prevent focus entering unrelated editable label.\n      Tab: () => toggleMenu(false),\n    }),\n    dom.on('focus', () => toggleMenu(true)),\n    commandGroup.attach(),\n  );\n\n  // Releases focus when closing the search bar, otherwise users could keep typing in without\n  // noticing.\n  const lis = model.isOpen.addListener(val => val || inputElem.blur());\n\n  return searchWrapper(\n    testId('wrapper'),\n    searchWrapper.cls('-expand', model.isOpen),\n    dom.autoDispose(commandGroup),\n    dom.autoDispose(lis),\n    // Make sure we don't attempt to call delayed callback after disposal.\n    dom.onDispose(() => toggleMenu.cancel()),\n    cssHoverCircle(\n      cssTopBarBtn('Search',\n        testId('icon'),\n        dom.on('click', focusAndSelect),\n        hoverTooltip(t('Search'), {key: 'topBarBtnTooltip'}),\n      )\n    ),\n    expandedSearch(\n      testId('input'),\n      inputElem,\n      dom.domComputed((use) => {\n        const noMatch = use(model.noMatch);\n        const isEmpty = use(model.isEmpty);\n        if (isEmpty) { return null; }\n        if (noMatch) { return cssLabel(t(\"No results\")); }\n        return [\n          cssArrowBtn(\n            icon('Dropdown'),\n            testId('next'),\n            // Prevent focus from being stolen from the input\n            dom.on('mousedown', (event) => event.preventDefault()),\n            dom.on('click', () => model.findNext()),\n            hoverTooltip(\n              [\n                t(\"Find Next \"),\n                cssShortcut(`(${['Enter', allCommands.findNext.humanKeys].join(', ')})`),\n              ],\n              {key: 'searchArrowBtnTooltip'}\n            ),\n          ),\n          cssArrowBtn(\n            icon('DropdownUp'),\n            testId('prev'),\n            // Prevent focus from being stolen from the input\n            dom.on('mousedown', (event) => event.preventDefault()),\n            dom.on('click', () => model.findPrev()),\n            hoverTooltip(\n              [\n                t(\"Find Previous \"),\n                cssShortcut(allCommands.findPrev.getKeysDesc()),\n              ],\n              {key: 'searchArrowBtnTooltip'}\n            ),\n          )\n        ];\n      }),\n      cssCloseBtn('CrossSmall',\n        testId('close'),\n        dom.on('click', () => toggleMenu(false))),\n      cssOptions(\n        labeledSquareCheckbox(model.multiPage, dom.text(model.allLabel)),\n        dom.on('mouseenter', () => keepExpanded = true),\n        dom.on('mouseleave', () => keepExpanded = false),\n        testId('option-all-pages'),\n      ),\n    )\n  );\n}\n"],"names":["debounce","t","makeT","Stepper","array","index","this","length","step","nextArrayFunc","inRange","p","then","setStart","value","RawSectionWrapper","constructor","_section","id","peek","view","activeSectionId","getRowId","waitObs","viewInstance","getLoadingDonePromise","PageRecWrapper","_page","_opener","sections","viewSections","collapsed","Set","activeCollapsedSections","has","filter","s","getViewId","FinderImpl","_gristDoc","_openDocPageCB","multiPage","matchFound","_pageStepper","_sectionStepper","_rowStepper","_fieldStepper","_pagesSwitched","_aborted","_searchRegexp","escaped","replace","RegExp","makeRegexp","_clearCursorHighlight","pageIndex","sectionIndex","rowIndex","fieldIndex","activeViewId","get","rawSections","docModel","visibleTables","sort","a","b","nativeCompare","tableNameDef","map","table","rawViewSection","Boolean","r","findIndex","viewModel","openPage","pages","visibleDocPages","page","viewRef","_initNewSectionShown","pos","cursor","getCursorPos","count","lastBreak","Date","now","_matches","_loadSection","delay","nextField","_isCurrentPosition","startPosition","console","log","JSON","stringify","getCurrentPosition","_highlight","next","_nextRow","_nextSection","_nextPage","_initNewSectionAny","section","tableModel","getTableModel","tableId","_sectionTableData","tableData","viewFields","_initFormatters","_initNewSectionCommon","skip","includes","parentKey","sortedRows","getKoArray","fetch","getRowIds","_fieldFormatters","f","formatter","warn","field","rowId","displayCol","displayColModel","getValue","colId","text","formatAny","test","cursorPos","sectionId","recursiveMoveToCursorPos","catch","reportError","scrollToCursor","viewPane","querySelector","classList","add","remove","clearTimeout","timeout","setTimeout","SearchModelImpl","Disposable","super","Observable","isOpen","isRunning","noMatch","isEmpty","_isRestartNeeded","_finder","findFirst","_value","_findFirst","autoDispose","addListener","v","set","allLabel","Computed","use","subscribe","_run","async","finder","matchNext","_updateFinder","abort","impl","_openDocPage","bind","isValid","init","cb","Error","viewId","openDocPage","searchWrapper","styled","theme","mediaSmall","expandedSearch","className","searchInput","input","cssArrowBtn","cssCloseBtn","icon","cssLabel","vars","cssOptions","cssShortcut","searchBar","model","testId","noTestId","keepExpanded","focusAndSelect","inputElem","focus","select","commandGroup","createGroup","find","findNext","findPrev","toggleMenu","onInput","type","placeholder","dom","Enter","ev","shiftKey","Escape","Tab","attach","lis","val","blur","cls","cancel","c","hoverTooltip","key","event","preventDefault","allCommands","join"],"sourceRoot":""}