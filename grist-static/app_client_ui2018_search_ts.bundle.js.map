{"version":3,"file":"app_client_ui2018_search_ts.bundle.js","mappings":"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","sources":["./app/client/models/SearchModel.ts?","./app/client/ui2018/search.ts?"],"sourcesContent":["// tslint:disable:no-console\n// TODO: Add documentation and clean up log statements.\n\nimport {GristDoc} from 'app/client/components/GristDoc';\nimport {PageRec, ViewFieldRec, ViewSectionRec} from 'app/client/models/DocModel';\nimport {reportError} from 'app/client/models/errors';\nimport {delay} from 'app/common/delay';\nimport {IDocPage} from 'app/common/gristUrls';\nimport {nativeCompare, waitObs} from 'app/common/gutil';\nimport {TableData} from 'app/common/TableData';\nimport {BaseFormatter} from 'app/common/ValueFormatter';\nimport { makeT } from 'app/client/lib/localization';\nimport {CursorPos} from 'app/plugin/GristAPI';\nimport {Computed, Disposable, Observable} from 'grainjs';\nimport debounce = require('lodash/debounce');\n\nconst t = makeT('SearchModel');\n\n/**\n * SearchModel used to maintain the state of the search UI.\n */\nexport interface SearchModel {\n  value: Observable<string>;       // string in the search input\n  isOpen: Observable<boolean>;     // indicates whether the search bar is expanded to show the input\n  noMatch: Observable<boolean>;    // indicates if there are no search matches\n  isEmpty: Observable<boolean>;     // indicates whether the value is empty\n  isRunning: Observable<boolean>;  // indicates that matching is in progress\n  multiPage: Observable<boolean>;   // if true will search across all pages\n  allLabel: Observable<string>;   // label to show instead of default 'Search all pages'\n\n  findNext(): Promise<void>;       // find next match\n  findPrev(): Promise<void>;       // find previous match\n}\n\ninterface SearchPosition {\n  pageIndex: number;\n  sectionIndex: number;\n  rowIndex: number;\n  fieldIndex: number;\n}\n\n/**\n * Stepper is an helper class that is used to implement stepping through all the cells of a\n * document. Fields belongs to rows, rows belongs to section and sections to pages. So this is four\n * steppers that must be used together, one for each level (field, rows, section and pages). When a\n * stepper reaches the end of its array, this is the `nextArrayFunc` callback, passed to the\n * `next()`, that is responsible for both taking a step at the higher level and updating the\n * stepper's array.\n */\nclass Stepper<T> {\n  public array: ReadonlyArray<T> = [];\n  public index: number = 0;\n\n  public inRange() {\n    return this.index >= 0 && this.index < this.array.length;\n  }\n\n  // Doing await at every step adds a ton of overhead; we can optimize by returning and waiting on\n  // Promises only when needed.\n  public next(step: number, nextArrayFunc: () => Promise<void>|void): Promise<void>|void {\n    this.index += step;\n    if (!this.inRange()) {\n      // If index reached the end of the array, take a step at a higher level to get a new array.\n      // For efficiency, only wait asynchronously if the callback returned a promise.\n      const p = nextArrayFunc();\n      if (p) {\n        return p.then(() => this.setStart(step));\n      } else {\n        this.setStart(step);\n      }\n    }\n  }\n\n  public setStart(step: number) {\n    this.index = step > 0 ? 0 : this.array.length - 1;\n  }\n\n  public get value(): T { return this.array[this.index]; }\n}\n\n/**\n * Interface that represents an ongoing search job which stops on the first match found.\n */\ninterface IFinder {\n  matchFound: boolean;             // true if a match was found\n  startPosition: SearchPosition;   // position at which to stop searching for a new match\n  abort(): void;                   // abort current search\n  matchNext(step: number): Promise<void>;      // next match\n  nextField(step: number): Promise<void>|void; // move the current position\n  getCurrentPosition(): SearchPosition;        // get the current position\n}\n\n// A callback to opening a page: useful to switch to next page during an ongoing search.\ntype DocPageOpener = (viewId: IDocPage) => Promise<void>;\n\n// To support Raw Data Views we will introduce a 'wrapped' page abstraction. Raw data\n// page is not a true page (it doesn't have a record), this will allow as to treat a raw view section\n// as if it were a PageRec.\ninterface ISearchablePageRec {\n  viewSections(): ViewSectionRec[];\n  activeSectionId(): number;\n  getViewId(): IDocPage;\n  openPage(): Promise<void>;\n}\n\nclass RawSectionWrapper implements ISearchablePageRec {\n  constructor(private _section: ViewSectionRec) {\n\n  }\n  public viewSections(): ViewSectionRec[] {\n    return [this._section];\n  }\n\n  public activeSectionId() {\n    return this._section.id.peek();\n  }\n\n  public getViewId(): IDocPage {\n    return 'data';\n  }\n\n  public async openPage() {\n    this._section.view.peek().activeSectionId(this._section.getRowId());\n    await waitObs(this._section.viewInstance);\n    await this._section.viewInstance.peek()?.getLoadingDonePromise();\n  }\n}\n\nclass PageRecWrapper implements ISearchablePageRec {\n  constructor(private _page: PageRec, private _opener: DocPageOpener) {\n\n  }\n  public viewSections(): ViewSectionRec[] {\n    const sections = this._page.view.peek().viewSections.peek().peek();\n    const collapsed = new Set(this._page.view.peek().activeCollapsedSections.peek());\n    const activeSectionId = this._page.view.peek().activeSectionId.peek();\n    // If active section is collapsed, it means it is rendered in the popup, so narrow\n    // down the search to only it.\n    const inPopup = collapsed.has(activeSectionId);\n    if (inPopup) {\n      return sections.filter((s) => s.getRowId() === activeSectionId);\n    }\n    return sections.filter((s) => !collapsed.has(s.getRowId()));\n  }\n\n  public activeSectionId() {\n    return this._page.view.peek().activeSectionId.peek();\n  }\n\n  public getViewId() {\n    return this._page.view.peek().getRowId();\n  }\n\n  public openPage() {\n    return this._opener(this.getViewId());\n  }\n}\n\n//activeSectionId\n\n/**\n * An implementation of an IFinder.\n */\nclass FinderImpl implements IFinder {\n  public matchFound = false;\n  public startPosition: SearchPosition;\n\n  private _searchRegexp: RegExp;\n  private _pageStepper = new Stepper<ISearchablePageRec>();\n  private _sectionStepper = new Stepper<ViewSectionRec>();\n  private _sectionTableData: TableData;\n  private _rowStepper = new Stepper<number>();\n  private _fieldStepper = new Stepper<ViewFieldRec>();\n  private _fieldFormatters: [ViewFieldRec, BaseFormatter][];\n  private _pagesSwitched: number = 0;\n  private _aborted = false;\n  private _clearCursorHighlight: (() => void)|undefined;\n\n  constructor(private _gristDoc: GristDoc, value: string, private _openDocPageCB: DocPageOpener,\n              public multiPage: Observable<boolean>) {\n    this._searchRegexp = makeRegexp(value);\n  }\n\n  public abort() {\n    this._aborted = true;\n    if (this._clearCursorHighlight) { this._clearCursorHighlight(); }\n  }\n\n  public getCurrentPosition(): SearchPosition {\n    return {\n      pageIndex: this._pageStepper.index,\n      sectionIndex: this._sectionStepper.index,\n      rowIndex: this._rowStepper.index,\n      fieldIndex: this._fieldStepper.index,\n    };\n  }\n\n  // Initialize the steppers. Returns false if anything goes wrong.\n  public async init(): Promise<boolean> {\n    // If we are on a raw view page, pretend that we are looking at true pages.\n    if ('data' === this._gristDoc.activeViewId.get()) {\n      // Get all raw sections.\n      const rawSections = this._gristDoc.docModel.visibleTables.peek()\n                              // sort in order that is the same as on the raw data list page,\n                              .sort((a, b) => nativeCompare(a.tableNameDef.peek(), b.tableNameDef.peek()))\n                              // get rawViewSection,\n                              .map(table => table.rawViewSection.peek())\n                              // and test if it isn't an empty record.\n                              .filter(s => Boolean(s.id.peek()));\n      // Pretend that those are pages.\n      this._pageStepper.array = rawSections.map(r => new RawSectionWrapper(r));\n      // Find currently selected one (by comparing to active section id)\n      this._pageStepper.index = rawSections.findIndex(s =>\n        s.getRowId() === this._gristDoc.viewModel.activeSectionId.peek());\n      // If we are at listing, where no section is active open the first page. Otherwise, search will fail.\n      if (this._pageStepper.index < 0) {\n        this._pageStepper.index = 0;\n        await this._pageStepper.value.openPage();\n      }\n    } else {\n      // Else read all visible pages.\n      const pages = this._gristDoc.docModel.visibleDocPages.peek();\n      this._pageStepper.array = pages.map(p => new PageRecWrapper(p, this._openDocPageCB));\n      this._pageStepper.index = pages.findIndex(page => page.viewRef.peek() === this._gristDoc.activeViewId.get());\n      if (this._pageStepper.index < 0) { return false; }\n    }\n\n    const sections = this._pageStepper.value.viewSections();\n    this._sectionStepper.array = sections;\n    this._sectionStepper.index = sections.findIndex(s => s.getRowId() === this._pageStepper.value.activeSectionId());\n    if (this._sectionStepper.index < 0) { return false; }\n\n    this._initNewSectionShown();\n\n    // Find the current cursor position in the current section.\n    const viewInstance = this._sectionStepper.value.viewInstance.peek()!;\n    const pos = viewInstance.cursor.getCursorPos();\n    this._rowStepper.index = pos.rowIndex!;\n    this._fieldStepper.index = pos.fieldIndex!;\n    return true;\n  }\n\n  public async matchNext(step: number): Promise<void> {\n    let count = 0;\n    let lastBreak = Date.now();\n\n    this._pagesSwitched = 0;\n\n    while (!this._matches() || ((await this._loadSection(step)) && !this._matches())) {\n\n      // If search was aborted, simply returns.\n      if (this._aborted) { return; }\n\n      // To avoid hogging the CPU for too long, check time periodically, and if we've been running\n      // for long enough, take a brief break. We choose a 5ms break every 20ms; and only check\n      // time every 100 iterations, to avoid excessive overhead purely due to time checks.\n      if ((++count) % 100 === 0 && Date.now() >= lastBreak + 20) {\n        await delay(5);\n        lastBreak = Date.now();\n      }\n\n      const p = this.nextField(step);\n      if (p) { await p; }\n\n      // Detect when we get back to the start position; this is where we break on no match.\n      if (this._isCurrentPosition(this.startPosition) && !this._matches()) {\n        console.log(\"SearchBar: reached start position without finding anything\");\n        this.matchFound = false;\n        return;\n      }\n\n      // A fail-safe to prevent certain bugs from causing infinite loops; break also if we scan\n      // through pages too many times.\n      // TODO: test it by disabling the check above.\n      if (this._pagesSwitched > this._pageStepper.array.length) {\n        console.log(\"SearchBar: aborting search due to too many page switches\");\n        this.matchFound = false;\n        return;\n      }\n    }\n    console.log(\"SearchBar: found a match at %s\", JSON.stringify(this.getCurrentPosition()));\n    this.matchFound = true;\n    await this._highlight();\n  }\n\n  public nextField(step: number): Promise<void>|void {\n    return this._fieldStepper.next(step, () => this._nextRow(step));\n  }\n\n  private _nextRow(step: number) {\n    return this._rowStepper.next(step, () => this._nextSection(step));\n  }\n\n  private async _nextSection(step: number) {\n    // Switching sections is rare enough that we don't worry about optimizing away `await` calls.\n    await this._sectionStepper.next(step, () => this._nextPage(step));\n    await this._initNewSectionAny();\n  }\n\n    // TODO There are issues with filtering. A section may have filters applied, and it may be\n    // auto-filtered (linked sections). If a tab is shown, we have the filtered list of rowIds; if\n    // the tab is not shown, it takes work to apply explicit filters. For linked sections, the\n    // sensible behavior seems to scan through ALL values, then once a match is found, set the\n    // cursor that determines the linking to include the matched row. And even that may not always\n    // be possible. So this is an open question.\n\n  private _initNewSectionCommon() {\n    const section = this._sectionStepper.value;\n    const tableModel = this._gristDoc.getTableModel(section.table.peek().tableId.peek());\n    this._sectionTableData = tableModel.tableData;\n\n    this._fieldStepper.array = section.viewFields().peek();\n    this._initFormatters();\n    return tableModel;\n  }\n\n  private _initNewSectionShown() {\n    this._initNewSectionCommon();\n    const viewInstance = this._sectionStepper.value.viewInstance.peek()!;\n    const skip = ['chart'].includes(this._sectionStepper.value.parentKey.peek());\n    this._rowStepper.array = skip ? [] : viewInstance.sortedRows.getKoArray().peek() as number[];\n  }\n\n  private async _initNewSectionAny() {\n    const tableModel = this._initNewSectionCommon();\n\n    const viewInstance = this._sectionStepper.value.viewInstance.peek();\n    const skip = ['chart'].includes(this._sectionStepper.value.parentKey.peek());\n    if (skip) {\n      this._rowStepper.array = [];\n    } else if (viewInstance) {\n      this._rowStepper.array = viewInstance.sortedRows.getKoArray().peek() as number[];\n    } else {\n      // If we are searching through another page (not currently loaded), we will NOT have a\n      // viewInstance, but we use the unsorted unfiltered row list, and if we find a match, the\n      // _loadSection() method will load the page and we'll repeat the search with a viewInstance.\n      await tableModel.fetch();\n      this._rowStepper.array = this._sectionTableData.getRowIds();\n    }\n  }\n\n  private async _nextPage(step: number) {\n    if (!this.multiPage.get()) { return; }\n    await this._pageStepper.next(step, () => undefined);\n    this._pagesSwitched++;\n\n    const view = this._pageStepper.value;\n    this._sectionStepper.array = view.viewSections();\n  }\n\n  private _initFormatters() {\n    this._fieldFormatters = this._fieldStepper.array.map(f => [f, f.formatter.peek()]);\n  }\n\n  private _matches(): boolean {\n    if (this._pageStepper.index < 0 || this._sectionStepper.index < 0 ||\n        this._rowStepper.index < 0 || this._fieldStepper.index < 0) {\n      console.warn(\"match outside\");\n      return false;\n    }\n    const field = this._fieldStepper.value;\n    let formatter = this._fieldFormatters[this._fieldStepper.index];\n    // When fields are removed during search (or reordered) we need to update\n    // formatters we retrieved on init.\n    if (!formatter || formatter[0 /* field */] !== field) {\n      this._initFormatters();\n      formatter = this._fieldFormatters[this._fieldStepper.index];\n    }\n    const rowId = this._rowStepper.value;\n    const displayCol = field.displayColModel.peek();\n\n    const value = this._sectionTableData.getValue(rowId, displayCol.colId.peek());\n\n    // TODO: Note that formatting dates is now the bulk of the performance cost.\n    const text = formatter[1  /* formatter */].formatAny(value);\n    return this._searchRegexp.test(text);\n  }\n\n  private async _loadSection(step: number): Promise<boolean> {\n    // If we found a match in a section for which we don't have a valid BaseView instance, we need\n    // to load the BaseView and start searching the section again, since the match we found does\n    // not take into account sort or filters. So we switch to the right page, wait for the\n    // viewInstance to be created, reset the section info, and return true to continue searching.\n    const section = this._sectionStepper.value;\n    if (!section.viewInstance.peek()) {\n      const view = this._pageStepper.value;\n      if (this._aborted) { return false; }\n      await view.openPage();\n      console.log(\"SearchBar: loading view %s section %s\", view.getViewId(), section.getRowId());\n      const viewInstance: any = await waitObs(section.viewInstance);\n      await viewInstance.getLoadingDonePromise();\n      this._initNewSectionShown();\n      this._rowStepper.setStart(step);\n      this._fieldStepper.setStart(step);\n      console.log(\"SearchBar: loaded view %s section %s\", view.getViewId(), section.getRowId());\n      return true;\n    }\n    return false;\n  }\n\n  // Highlights the cell at the current position.\n  private async _highlight() {\n    if (this._aborted) { return; }\n\n    const section = this._sectionStepper.value;\n    const sectionId = section.getRowId();\n    const cursorPos: CursorPos = {\n      sectionId,\n      rowId: this._rowStepper.value,\n      fieldIndex: this._fieldStepper.index,\n    };\n    await this._gristDoc.recursiveMoveToCursorPos(cursorPos, true).catch(reportError);\n    if (this._aborted) { return; }\n\n    // Highlight the selected cursor, after giving it a chance to update. We find the cursor in\n    // this ad-hoc way rather than use observables, to avoid the overhead of *every* cell\n    // depending on an additional observable.\n    await delay(0);\n    const viewInstance = (await waitObs(section.viewInstance))!;\n    await viewInstance.getLoadingDonePromise();\n    if (this._aborted) { return; }\n    // Make sure we are at good place. This is important when the cursor\n    // was already in a matched record, but the record was scrolled away.\n    viewInstance.scrollToCursor(true).catch(reportError);\n\n    const cursor = viewInstance.viewPane.querySelector('.selected_cursor');\n    if (cursor) {\n      cursor.classList.add('search-match');\n      this._clearCursorHighlight = () => {\n        cursor.classList.remove('search-match');\n        clearTimeout(timeout);\n        this._clearCursorHighlight = undefined;\n      };\n      const timeout = setTimeout(this._clearCursorHighlight, 20);\n    }\n  }\n\n  private _isCurrentPosition(pos: SearchPosition): boolean {\n    return (\n      this._pageStepper.index === pos.pageIndex &&\n        this._sectionStepper.index === pos.sectionIndex &&\n        this._rowStepper.index === pos.rowIndex &&\n        this._fieldStepper.index === pos.fieldIndex\n    );\n  }\n}\n\n/**\n * Implementation of SearchModel used to construct the search UI.\n */\nexport class SearchModelImpl extends Disposable implements SearchModel {\n  public readonly value = Observable.create(this, '');\n  public readonly isOpen = Observable.create(this, false);\n  public readonly isRunning = Observable.create(this, false);\n  public readonly noMatch = Observable.create(this, true);\n  public readonly isEmpty = Observable.create(this, true);\n  public readonly multiPage = Observable.create(this, false);\n  public readonly allLabel: Computed<string>;\n\n  private _isRestartNeeded = false;\n  private _finder: IFinder|null = null;\n\n  constructor(private _gristDoc: GristDoc) {\n    super();\n\n    // Listen to input value changes (debounced) to activate searching.\n    const findFirst = debounce((_value: string) => this._findFirst(_value), 100);\n    this.autoDispose(this.value.addListener(v => { this.isRunning.set(true); void findFirst(v); }));\n\n    // Set this.noMatch to false when multiPage gets turned ON.\n    this.autoDispose(this.multiPage.addListener(v => { if (v) { this.noMatch.set(false); } }));\n\n    this.allLabel = Computed.create(this, use => use(this._gristDoc.activeViewId) === 'data' ?\n      t('Search all tables') : t('Search all pages'));\n\n    // Schedule a search restart when user changes pages (otherwise search would resume from the\n    // previous page that is not shown anymore). Also revert noMatch flag when in single page mode.\n    this.autoDispose(this._gristDoc.activeViewId.addListener(() => {\n      if (!this.multiPage.get()) { this.noMatch.set(false); }\n      this._isRestartNeeded = true;\n    }));\n\n    // On Raw data view, whenever table is closed (so activeSectionId = 0), restart search.\n    this.autoDispose(this._gristDoc.viewModel.activeSectionId.subscribe((sectionId) => {\n      if (this._gristDoc.activeViewId.get() === 'data' && sectionId === 0) {\n        this._isRestartNeeded = true;\n        this.noMatch.set(false);\n      }\n    }));\n  }\n\n  public async findNext() {\n    if (this.isRunning.get() || this.noMatch.get()) { return; }\n    if (this._isRestartNeeded) { return this._findFirst(this.value.get()); }\n    await this._run(async (finder) => {\n      await finder.nextField(1);\n      await finder.matchNext(1);\n    });\n  }\n\n  public async findPrev() {\n    if (this.isRunning.get() || this.noMatch.get()) { return; }\n    if (this._isRestartNeeded) { return this._findFirst(this.value.get()); }\n    await this._run(async (finder) => {\n      await finder.nextField(-1);\n      await finder.matchNext(-1);\n    });\n  }\n\n  private async _findFirst(value: string) {\n    this._isRestartNeeded = false;\n    this.isEmpty.set(!value);\n    await this._updateFinder(value);\n    if (!value || !this._finder) { this.noMatch.set(true); return; }\n    await this._run(async (finder) => {\n      await finder.matchNext(1);\n    });\n  }\n\n  private async _updateFinder(value: string) {\n    if (this._finder) { this._finder.abort(); }\n    const impl = new FinderImpl(this._gristDoc, value, this._openDocPage.bind(this), this.multiPage);\n    const isValid = await impl.init();\n    this._finder = isValid ? impl : null;\n  }\n\n  // Internal helper that runs cb, passing it the current `this._finder` as first argument and sets\n  // this.isRunning to true until the call resolves. It also takes care of updating this.noMatch.\n  private async _run(cb: (finder: IFinder) => Promise<void>) {\n\n    const finder = this._finder;\n    if (!finder) { throw new Error(\"SearchModel: finder is not defined\"); }\n\n    try {\n      this.isRunning.set(true);\n      finder.startPosition = finder.getCurrentPosition();\n      await cb(finder);\n    } finally {\n      this.isRunning.set(false);\n      this.noMatch.set(!finder.matchFound);\n    }\n  }\n\n  // Opens doc page without triggering a restart.\n  private async _openDocPage(viewId: IDocPage) {\n    await this._gristDoc.openDocPage(viewId);\n    this._isRestartNeeded = false;\n  }\n}\n\nfunction makeRegexp(value: string) {\n  // From https://stackoverflow.com/a/3561711/328565\n  const escaped = value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  return new RegExp(escaped, 'i');\n}\n","/**\n * Search icon that expands to a search bar and collapse on 'x' or blur.\n * Takes a `SearchModel` that controls the search behavior.\n */\nimport { allCommands, createGroup } from 'app/client/components/commands';\nimport { makeT } from 'app/client/lib/localization';\nimport { reportError } from 'app/client/models/AppModel';\nimport { SearchModel } from 'app/client/models/SearchModel';\nimport { hoverTooltip } from 'app/client/ui/tooltips';\nimport { cssHoverCircle, cssTopBarBtn } from 'app/client/ui/TopBarCss';\nimport { labeledSquareCheckbox } from 'app/client/ui2018/checkbox';\nimport { mediaSmall, theme, vars } from 'app/client/ui2018/cssVars';\nimport { icon } from 'app/client/ui2018/icons';\nimport { dom, input, styled } from 'grainjs';\nimport { noTestId, TestId } from 'grainjs';\nimport debounce = require('lodash/debounce');\n\nexport * from 'app/client/models/SearchModel';\n\nconst t = makeT('search');\n\nconst EXPAND_TIME = .5;\n\nconst searchWrapper = styled('div', `\n  display: flex;\n  flex: initial;\n  align-items: center;\n  box-sizing: border-box;\n  border: 1px solid transparent;\n  padding: 0px 16px;\n  width: 50px;\n  height: 100%;\n  max-height: 50px;\n  transition: width 0.4s;\n  position: relative;\n  &-expand {\n    width: 100% !important;\n    border: 1px solid ${theme.searchBorder};\n  }\n  @media ${mediaSmall} {\n    & {\n      width: 32px;\n      padding: 0px;\n    }\n  }\n`);\n\nconst expandedSearch = styled('div', `\n  display: flex;\n  flex-grow: 0;\n  align-items: center;\n  width: 0;\n  opacity: 0;\n  align-self: stretch;\n  transition: width ${EXPAND_TIME}s, opacity ${EXPAND_TIME / 2}s ${EXPAND_TIME / 2}s;\n  .${searchWrapper.className}-expand > & {\n    width: auto;\n    flex-grow: 1;\n    opacity: 1;\n  }\n`);\n\nconst searchInput = styled(input, `\n  background-color: ${theme.topHeaderBg};\n  color: ${theme.inputFg};\n  outline: none;\n  border: none;\n  margin: 0;\n  padding: 0;\n  padding-left: 4px;\n  box-sizing: border-box;\n  align-self: stretch;\n  width: 0;\n  transition: width ${EXPAND_TIME}s;\n  .${searchWrapper.className}-expand & {\n    width: 100%;\n  }\n  &::placeholder {\n    color: ${theme.inputPlaceholderFg};\n  }\n`);\n\nconst cssArrowBtn = styled('div', `\n  font-size: 14px;\n  padding: 3px;\n  cursor: pointer;\n  margin: 2px 4px;\n  visibility: hidden;\n  width: 24px;\n  height: 24px;\n  background-color: ${theme.searchPrevNextButtonBg};\n  --icon-color: ${theme.searchPrevNextButtonFg};\n  border-radius: 3px;\n  text-align: center;\n  display: flex;\n  align-items: center;\n\n  .${searchWrapper.className}-expand & {\n    visibility: visible;\n  }\n`);\n\nconst cssCloseBtn = styled(icon, `\n  cursor: pointer;\n  background-color: ${theme.controlFg};\n  margin-left: 4px;\n  flex-shrink: 0;\n`);\n\nconst cssLabel = styled('span', `\n  font-size: ${vars.smallFontSize};\n  color: ${theme.lightText};\n  white-space: nowrap;\n  margin-right: 12px;\n`);\n\nconst cssOptions = styled('div', `\n  background: ${theme.topHeaderBg};\n  position: absolute;\n  right: 0;\n  top: 48px;\n  z-index: 1;\n  padding: 2px 4px;\n  overflow: hidden;\n  white-space: nowrap;\n`);\n\nconst cssShortcut = styled('span', `\n  color: ${theme.lightText};\n`);\n\nexport function searchBar(model: SearchModel, testId: TestId = noTestId) {\n  let keepExpanded = false;\n\n  const focusAndSelect = () => { inputElem.focus(); inputElem.select(); };\n\n  const commandGroup = createGroup({\n    find: focusAndSelect,\n    // On Mac, Firefox has a default behaviour witch causes to close the search bar on Cmd+g and\n    // Cmd+shirt+G. Returning false is a Mousetrap convenience which prevents that.\n    findNext: () => { model.findNext().catch(reportError); return false; },\n    findPrev: () => { model.findPrev().catch(reportError); return false; },\n  }, null, true);\n\n  const toggleMenu = debounce((_value?: boolean) => {\n    model.isOpen.set(_value === undefined ? !model.isOpen.get() : _value);\n  }, 100);\n  const inputElem: HTMLInputElement = searchInput(model.value, {onInput: true},\n    {type: 'text', placeholder: t(\"Search in document\")},\n    dom.on('blur', () => (\n      keepExpanded ?\n        setTimeout(() => inputElem.focus(), 0) :\n        toggleMenu(false)\n    )),\n    dom.onKeyDown({\n      Enter: (ev) => ev.shiftKey ? model.findPrev() : model.findNext(),\n      Escape: () => { keepExpanded = false; toggleMenu(false); },\n      // Catch both Tab and Shift+Tab to prevent focus entering unrelated editable label.\n      Tab: () => toggleMenu(false),\n    }),\n    dom.on('focus', () => toggleMenu(true)),\n    commandGroup.attach(),\n  );\n\n  // Releases focus when closing the search bar, otherwise users could keep typing in without\n  // noticing.\n  const lis = model.isOpen.addListener(val => val || inputElem.blur());\n\n  return searchWrapper(\n    testId('wrapper'),\n    searchWrapper.cls('-expand', model.isOpen),\n    dom.autoDispose(commandGroup),\n    dom.autoDispose(lis),\n    // Make sure we don't attempt to call delayed callback after disposal.\n    dom.onDispose(() => toggleMenu.cancel()),\n    cssHoverCircle(\n      cssTopBarBtn('Search',\n        testId('icon'),\n        dom.on('click', focusAndSelect),\n        hoverTooltip(t('Search'), {key: 'topBarBtnTooltip'}),\n      )\n    ),\n    expandedSearch(\n      testId('input'),\n      inputElem,\n      dom.domComputed((use) => {\n        const noMatch = use(model.noMatch);\n        const isEmpty = use(model.isEmpty);\n        if (isEmpty) { return null; }\n        if (noMatch) { return cssLabel(t(\"No results\")); }\n        return [\n          cssArrowBtn(\n            icon('Dropdown'),\n            testId('next'),\n            // Prevent focus from being stolen from the input\n            dom.on('mousedown', (event) => event.preventDefault()),\n            dom.on('click', () => model.findNext()),\n            hoverTooltip(\n              [\n                t(\"Find Next \"),\n                cssShortcut(`(${['Enter', allCommands.findNext.humanKeys].join(', ')})`),\n              ],\n              {key: 'searchArrowBtnTooltip'}\n            ),\n          ),\n          cssArrowBtn(\n            icon('DropdownUp'),\n            testId('prev'),\n            // Prevent focus from being stolen from the input\n            dom.on('mousedown', (event) => event.preventDefault()),\n            dom.on('click', () => model.findPrev()),\n            hoverTooltip(\n              [\n                t(\"Find Previous \"),\n                cssShortcut(allCommands.findPrev.getKeysDesc()),\n              ],\n              {key: 'searchArrowBtnTooltip'}\n            ),\n          )\n        ];\n      }),\n      cssCloseBtn('CrossSmall',\n        testId('close'),\n        dom.on('click', () => toggleMenu(false))),\n      cssOptions(\n        labeledSquareCheckbox(model.multiPage, dom.text(model.allLabel)),\n        dom.on('mouseenter', () => keepExpanded = true),\n        dom.on('mouseleave', () => keepExpanded = false),\n        testId('option-all-pages'),\n      ),\n    )\n  );\n}\n"],"names":[],"sourceRoot":""}