{"version":3,"file":"app_client_lib_ACSelect_ts-app_client_lib_copyToClipboard_ts-app_client_lib_testState_ts-app_-c1368b.bundle.js","mappings":"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","sources":["./app/client/lib/ACIndex.ts?","./app/client/lib/ACSelect.ts?","./app/client/lib/autocomplete.ts?","./app/client/lib/copyToClipboard.ts?","./app/client/lib/testState.ts?","./app/client/ui/shadowScroll.ts?"],"sourcesContent":["/**\n * A search index for auto-complete suggestions.\n *\n * This implementation indexes words, and suggests items based on a best-match score, including\n * amount of overlap and position of words. It searches case-insensitively and only at the start\n * of words. E.g. searching for \"Blue\" would match \"Blu\" in \"Lavender Blush\", but searching for\n * \"lush\" would only match the \"L\" in \"Lavender\".\n */\n\nimport {localeCompare, nativeCompare, sortedIndex} from 'app/common/gutil';\nimport {DomContents} from 'grainjs';\nimport escapeRegExp = require(\"lodash/escapeRegExp\");\nimport deburr = require(\"lodash/deburr\");\nimport split = require(\"lodash/split\");\n\nexport interface ACItem {\n  // This should be a trimmed lowercase version of the item's text. It may be an accessor.\n  // Note that items with empty cleanText are never suggested.\n  cleanText: string;\n}\n\n// Returns a trimmed, lowercase version of a string,\n// from which accents and other diacritics have been removed,\n// so that autocomplete is case- and accent-insensitive.\nexport function normalizeText(text: string): string {\n  return deburr(text).trim().toLowerCase();\n}\n\n// Regexp used to split text into words; includes nearly all punctuation. This means that\n// \"foo-bar\" may be searched by \"bar\", but it's impossible to search for punctuation itself (e.g.\n// \"a-b\" and \"a+b\" are not distinguished). (It's easy to exclude unicode punctuation too if the\n// need arises, see https://stackoverflow.com/a/25575009/328565).\nconst wordSepRegexp = /[\\s!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]+/;\n\n/**\n * An auto-complete index, which simply allows searching for a string.\n */\nexport interface ACIndex<Item extends ACItem> {\n  search(searchText: string): ACResults<Item>;\n}\n\n// Splits text into an array of pieces, with odd-indexed pieces being the ones to highlight.\nexport type HighlightFunc = (text: string) => string[];\n\nexport const highlightNone: HighlightFunc = (text) => [text];\n\n/**\n * AutoComplete results include the suggested items, which one to highlight, and a function for\n * highlighting the matched portion of each item.\n */\nexport interface ACResults<Item extends ACItem> {\n  // Matching items in order from best match to worst.\n  items: Item[];\n\n  // May be used to highlight matches using buildHighlightedDom().\n  highlightFunc: HighlightFunc;\n\n  // index of a good match (normally 0), or -1 if no great match\n  selectIndex: number;\n}\n\ninterface Word {\n  word: string;     // The indexed word\n  index: number;    // Index into _allItems for the item containing this word.\n  pos: number;      // Position of the word within the item where it occurred.\n}\n\n/**\n * Implements a search index. It doesn't currently support updates; when any values change, the\n * index needs to be rebuilt from scratch.\n */\nexport class ACIndexImpl<Item extends ACItem> implements ACIndex<Item> {\n  private _allItems: Item[];\n\n  // All words from _allItems, sorted.\n  private _words: Word[];\n\n  // Creates an index for the given list of items.\n  // The max number of items to suggest may be set using _maxResults (default is 50).\n  // If _keepOrder is true, best matches will be suggested in the order they occur in items,\n  // rather than order by best score.\n  constructor(items: Item[], private _maxResults: number = 50, private _keepOrder = false) {\n    this._allItems = items.slice(0);\n\n    // Collects [word, occurrence, position] tuples for all words in _allItems.\n    const allWords: Word[] = [];\n    for (let index = 0; index < this._allItems.length; index++) {\n      const item = this._allItems[index];\n      const words = item.cleanText.split(wordSepRegexp).filter(w => w);\n      for (let pos = 0; pos < words.length; pos++) {\n        allWords.push({word: words[pos], index, pos});\n      }\n    }\n\n    allWords.sort((a, b) => localeCompare(a.word, b.word));\n    this._words = allWords;\n  }\n\n\n  // The main search function. SearchText will be cleaned (trimmed and lowercased) at the start.\n  // Empty search text returns the first N items in the search universe.\n  public search(searchText: string): ACResults<Item> {\n    const cleanedSearchText = normalizeText(searchText);\n    const searchWords = cleanedSearchText.split(wordSepRegexp).filter(w => w);\n\n    // Maps item index in _allItems to its score.\n    const myMatches = new Map<number, number>();\n\n    if (searchWords.length > 0) {\n      // For each of searchWords, go through items with an overlap, and update their scores.\n      for (let k = 0; k < searchWords.length; k++) {\n        const searchWord = searchWords[k];\n        for (const [itemIndex, score] of this._findOverlaps(searchWord, k)) {\n          myMatches.set(itemIndex, (myMatches.get(itemIndex) || 0) + score);\n        }\n      }\n\n      // Give an extra point to items that start with the searchText.\n      for (const [itemIndex, score] of myMatches) {\n        if (this._allItems[itemIndex].cleanText.startsWith(cleanedSearchText)) {\n          myMatches.set(itemIndex, score + 1);\n        }\n      }\n    }\n\n    // Array of pairs [itemIndex, score], sorted by score (desc) and itemIndex.\n    const sortedMatches = Array.from(myMatches)\n      .sort((a, b) => nativeCompare(b[1], a[1]) || nativeCompare(a[0], b[0]))\n      .slice(0, this._maxResults);\n\n    const itemIndices: number[] = sortedMatches.map(([index, score]) => index);\n\n    // Append enough non-matching indices to reach maxResults.\n    for (let i = 0; i < this._allItems.length && itemIndices.length < this._maxResults; i++) {\n      if (this._allItems[i].cleanText && !myMatches.has(i)) {\n        itemIndices.push(i);\n      }\n    }\n\n    if (this._keepOrder) {\n      itemIndices.sort(nativeCompare);\n    }\n    const items = itemIndices.map(index => this._allItems[index]);\n\n    if (!cleanedSearchText) {\n      // In this case we are just returning the first few items.\n      return {items, highlightFunc: highlightNone, selectIndex: -1};\n    }\n\n    const highlightFunc = highlightMatches.bind(null, searchWords);\n\n    // If we have a best match, and any word in it actually starts with the search text, report it\n    // as a default selection for highlighting. Otherwise, no item will be auto-selected.\n    let selectIndex = sortedMatches.length > 0 ? itemIndices.indexOf(sortedMatches[0][0]) : -1;\n    if (selectIndex >= 0 && !startsWithText(items[selectIndex], cleanedSearchText, searchWords)) {\n      selectIndex = -1;\n    }\n    return {items, highlightFunc, selectIndex};\n  }\n\n  /**\n   * Given one of the search words, looks it up in the indexed list of words and searches up and\n   * down the list for all words that share a prefix with it. Each such word contributes something\n   * to the score of the index entry it is a part of.\n   *\n   * Returns a Map from the index entry (index into _allItems) to the score which this searchWord\n   * contributes to it.\n   *\n   * The searchWordPos argument is the position of searchWord in the overall search text (e.g. 0\n   * if it's the first word). It is used for the position bonus, to give higher scores to entries\n   * whose words occur in the same order as in the search text.\n   */\n  private _findOverlaps(searchWord: string, searchWordPos: number): Map<number, number> {\n    const insertIndex = sortedIndex<{word: string}>(this._words, {word: searchWord},\n      (a, b) => localeCompare(a.word, b.word));\n\n    // Maps index of item to its score.\n    const scored = new Map<number, number>();\n\n    // Search up and down the list, accepting smaller and smaller overlap.\n    for (const step of [1, -1]) {\n      let prefix = searchWord;\n      let index = insertIndex + (step > 0 ? 0 : -1);\n      while (prefix && index >= 0 && index < this._words.length) {\n        for ( ; index >= 0 && index < this._words.length; index += step) {\n          const wordEntry = this._words[index];\n          // Once we reach a word that doesn't start with our prefix, break this loop, so we can\n          // reduce the length of the prefix and keep scanning.\n          if (!wordEntry.word.startsWith(prefix)) { break; }\n\n          // The contribution of this word's to the score consists primarily of the length of\n          // overlap (i.e. length for the current prefix).\n          const baseScore = prefix.length;\n\n          // To this we add 1 if the word matches exactly.\n          const fullWordBonus = (wordEntry.word === searchWord ? 1 : 0);\n\n          // To prefer matches where words occur in the same order as searched (e.g. searching for\n          // \"Foo B\" should prefer \"Foo Bar\" over \"Bar Foo\"), we give a bonus based on the\n          // position of the word in the search text and the entry text. (If positions match as\n          // 0:0 and 1:1, the total position bonus is 2^0+2^(-2)=1.25; while the bonus from 0:1\n          // and 1:0 would be 2^(-1) + 2^(-1)=1.0.)\n          const positionBonus = Math.pow(2, -(searchWordPos + wordEntry.pos));\n\n          const itemScore = baseScore + fullWordBonus + positionBonus;\n          // Each search word contributes only one score (e.g. a search for \"Foo\" will partially\n          // match both words in \"forty five\", but only the higher of the matches will count).\n          if (itemScore >= (scored.get(wordEntry.index) || 0)) {\n            scored.set(wordEntry.index, itemScore);\n          }\n        }\n        prefix = prefix.slice(0, -1);\n      }\n    }\n    return scored;\n  }\n}\n\n\nexport type BuildHighlightFunc = (match: string) => DomContents;\n\n/**\n * Converts text to DOM with matching bits of text rendered using highlight(match) function.\n */\nexport function buildHighlightedDom(\n  text: string, highlightFunc: HighlightFunc, highlight: BuildHighlightFunc\n): DomContents {\n  if (!text) { return text; }\n  const parts = highlightFunc(text);\n  return parts.map((part, k) => k % 2 ? highlight(part) : part);\n}\n\n\n// Same as wordSepRegexp, but with capturing parentheses.\nconst wordSepRegexpParen = new RegExp(`(${wordSepRegexp.source})`);\n\n/**\n * Splits text into pieces, with odd-numbered pieces the ones matching a prefix of some\n * searchWord, i.e. the ones to highlight.\n */\nfunction highlightMatches(searchWords: string[], text: string): string[] {\n  const textParts = text.split(wordSepRegexpParen);\n  const outputs = [''];\n  for (let i = 0; i < textParts.length; i += 2) {\n    const word = textParts[i];\n    const separator = textParts[i + 1] || '';\n    // deburr (remove diacritics) was used to produce searchWords, so `word` needs to match that.\n    const prefixLen = findLongestPrefixLen(deburr(word).toLowerCase(), searchWords);\n    if (prefixLen === 0) {\n      outputs[outputs.length - 1] += word + separator;\n    } else {\n      // Split into unicode 'characters' that keep diacritics combined\n      const chars = split(word, '');\n      outputs.push(\n        chars.slice(0, prefixLen).join(''),\n        chars.slice(prefixLen).join('') + separator\n      );\n    }\n  }\n  return outputs;\n}\n\nfunction findLongestPrefixLen(text: string, choices: string[]): number {\n  return choices.reduce((max, choice) => Math.max(max, findCommonPrefixLength(text, choice)), 0);\n}\n\nfunction findCommonPrefixLength(text1: string, text2: string): number {\n  let i = 0;\n  while (i < text1.length && text1[i] === text2[i]) { ++i; }\n  return i;\n}\n\n/**\n * Checks whether `item` starts with `text`, or whether all words of text are prefixes of the\n * words of `item`. (E.g. it would return true if item is \"New York\", and text is \"ne yo\".)\n */\nfunction startsWithText(item: ACItem, text: string, searchWords: string[]): boolean {\n  if (item.cleanText.startsWith(text)) { return true; }\n\n  const regexp = new RegExp(searchWords.map(w => `\\\\b` + escapeRegExp(w)).join('.*'));\n  const cleanText = item.cleanText.split(wordSepRegexp).join(' ');\n  return regexp.test(cleanText);\n}\n","import {ACIndex, ACItem, buildHighlightedDom} from 'app/client/lib/ACIndex';\nimport {Autocomplete, IAutocompleteOptions} from 'app/client/lib/autocomplete';\nimport {theme} from \"app/client/ui2018/cssVars\";\nimport {icon} from \"app/client/ui2018/icons\";\nimport {menuCssClass} from 'app/client/ui2018/menus';\nimport {dom, DomElementArg, Holder, IDisposableOwner, Observable, styled} from 'grainjs';\n\nexport interface ACSelectItem extends ACItem {\n  value: string;\n  label: string;\n}\n\n/**\n * Builds a text input with an autocomplete dropdown.\n * Note that because it is currently only used in the right-side panel, it is designed to avoid\n * keeping focus.\n */\nexport function buildACSelect(\n  owner: IDisposableOwner,\n  options: {\n    disabled?: Observable<boolean>,\n    acIndex: ACIndex<ACSelectItem>,\n    valueObs: Observable<string>,\n    save: (value: string, item: ACSelectItem|undefined) => Promise<void>|void\n  },\n  ...args: DomElementArg[]\n) {\n  const {acIndex, valueObs, save} = options;\n  const acHolder = Holder.create<Autocomplete<ACSelectItem>>(owner);\n  let textInput: HTMLInputElement;\n\n  const isOpen = () => !acHolder.isEmpty();\n  const acOpen = () => acHolder.isEmpty() && Autocomplete.create(acHolder, textInput, acOptions);\n  const acClose = () => acHolder.clear();\n  const finish = () => { acClose(); textInput.blur(); };\n  const revert = () => { textInput.value = valueObs.get(); finish(); };\n  const commitOrRevert = async () => { (await commitIfValid()) || revert(); };\n  const openOrCommit = () => { isOpen() ? commitOrRevert().catch(() => {}) : acOpen(); };\n\n  const commitIfValid = async () => {\n    const item = acHolder.get()?.getSelectedItem();\n    if (item) {\n      textInput.value = item.value;\n    }\n    textInput.disabled = true;\n    try {\n      await save(textInput.value, item);\n      finish();\n      return true;\n    } catch (e) {\n      return false;\n    } finally {\n      textInput.disabled = false;\n    }\n  };\n\n  const onMouseDown = (ev: MouseEvent) => {\n    ev.preventDefault();    // Don't let it affect focus, since we focus/blur manually.\n    if (options.disabled?.get()) {\n      return;\n    }\n    if (!isOpen()) { textInput.focus(); }\n    openOrCommit();\n  };\n\n  const acOptions: IAutocompleteOptions<ACSelectItem> = {\n    menuCssClass: `${menuCssClass} test-acselect-dropdown`,\n    search: async (term: string) => acIndex.search(term),\n    renderItem: (item, highlightFunc) =>\n      cssSelectItem(buildHighlightedDom(item.label, highlightFunc, cssMatchText)),\n    getItemText: (item) => item.value,\n    onClick: commitIfValid,\n  };\n\n  return cssSelectBtn(\n    textInput = cssInput({type: 'text'},\n      dom.prop('value', valueObs),\n      dom.on('focus', (ev, elem) => elem.select()),\n      dom.on('blur', commitOrRevert),\n      dom.prop(\"disabled\", (use) => options.disabled ? use(options.disabled) : false),\n      dom.onKeyDown({\n        Escape: revert,\n        Enter: openOrCommit,\n        ArrowDown: acOpen,\n        Tab: commitIfValid,\n      }),\n      dom.on('input', acOpen),\n    ),\n    dom.on('mousedown', onMouseDown),\n    cssIcon('Dropdown'),\n    ...args\n  );\n}\n\nconst cssSelectBtn = styled('div', `\n  position: relative;\n  width: 100%;\n  height: 30px;\n  color: ${theme.selectButtonFg};\n  --icon-color: ${theme.selectButtonFg};\n`);\n\nexport const cssSelectItem = styled('li', `\n  color: ${theme.menuItemFg};\n  display: block;\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  outline: none;\n  padding: var(--weaseljs-menu-item-padding, 8px 24px);\n  cursor: pointer;\n\n  &.selected {\n    background-color: ${theme.menuItemSelectedBg};\n    color:            ${theme.menuItemSelectedFg};\n  }\n`);\n\nconst cssInput = styled('input', `\n  color: ${theme.inputFg};\n  background-color: ${theme.inputBg};\n  appearance: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  height: 100%;\n  width: 100%;\n  padding: 0 6px;\n  outline: none;\n  border: 1px solid ${theme.inputBorder};\n  border-radius: 3px;\n  cursor: pointer;\n  line-height: 16px;\n  cursor: pointer;\n\n  &:disabled {\n    color: ${theme.inputDisabledFg};\n    background-color: ${theme.inputDisabledBg};\n  }\n  &:focus {\n    cursor: initial;\n    outline: none;\n    box-shadow: 0px 0px 2px 2px ${theme.inputFocus};\n  }\n  &::placeholder {\n    color: ${theme.inputPlaceholderFg};\n  }\n`);\n\nconst cssIcon = styled(icon, `\n  position: absolute;\n  right: 6px;\n  top: calc(50% - 8px);\n`);\n\nconst cssMatchText = styled('span', `\n  color: ${theme.autocompleteMatchText};\n  .selected > & {\n    color: ${theme.autocompleteSelectedMatchText};\n  }\n`);\n","/**\n * Implements an autocomplete dropdown.\n */\nimport {createPopper, Modifier, Instance as Popper, Options as PopperOptions} from '@popperjs/core';\nimport {ACItem, ACResults, HighlightFunc} from 'app/client/lib/ACIndex';\nimport {reportError} from 'app/client/models/errors';\nimport {Disposable, dom, EventCB, IDisposable} from 'grainjs';\nimport {obsArray, onKeyElem, styled} from 'grainjs';\nimport merge = require('lodash/merge');\nimport maxSize from 'popper-max-size-modifier';\nimport {cssMenu} from 'popweasel';\n\n\nexport interface IAutocompleteOptions<Item extends ACItem> {\n  // If provided, applies the css class to the menu container. Could be multiple, space-separated.\n  menuCssClass?: string;\n\n  // A single class name to add for the selected item, or 'selected' by default.\n  selectedCssClass?: string;\n\n  // Popper options for positioning the popup.\n  popperOptions?: Partial<PopperOptions>;\n\n  // To which element to append the popup content. Null means triggerElem.parentNode; string is\n  // a selector for the closest matching ancestor of triggerElem, e.g. 'body'.\n  // Defaults to the document body.\n  attach?: Element|string|null;\n\n  // Given a search term, return the list of Items to render.\n  search(searchText: string): Promise<ACResults<Item>>;\n\n  // Function to render a single item.\n  renderItem(item: Item, highlightFunc: HighlightFunc): HTMLElement;\n\n  // Get text for the text input for a selected item, i.e. the text to present to the user.\n  getItemText(item: Item): string;\n\n  // A callback triggered when user clicks one of the choices.\n  onClick?(): void;\n}\n\n/**\n * An instance of an open Autocomplete dropdown.\n */\nexport class Autocomplete<Item extends ACItem> extends Disposable {\n  // The UL element containing the actual menu items.\n  protected _menuContent: HTMLElement;\n\n  // Index into _items as well as into _menuContent, -1 if nothing selected.\n  protected _selectedIndex: number = -1;\n\n  // Currently selected element.\n  protected _selected: HTMLElement|null = null;\n\n  private _popper: Popper;\n  private _mouseOver: {reset(): void};\n  private _lastAsTyped: string;\n  private _items = this.autoDispose(obsArray<Item>([]));\n  private _highlightFunc: HighlightFunc;\n\n  constructor(\n    private _triggerElem: HTMLInputElement | HTMLTextAreaElement,\n    private readonly _options: IAutocompleteOptions<Item>,\n  ) {\n    super();\n\n    const content = cssMenuWrap(\n      this._menuContent = cssMenu({class: _options.menuCssClass || ''},\n        dom.forEach(this._items, (item) => _options.renderItem(item, this._highlightFunc)),\n        dom.style('min-width', _triggerElem.getBoundingClientRect().width + 'px'),\n        dom.on('mouseleave', (ev) => this._setSelected(-1, true)),\n        dom.on('click', (ev) => {\n          this._setSelected(this._findTargetItem(ev.target), true);\n          if (_options.onClick) { _options.onClick(); }\n        })\n      ),\n      // Prevent trigger element from being blurred on click.\n      dom.on('mousedown', (ev) => ev.preventDefault()),\n    );\n\n    this._mouseOver = attachMouseOverOnMove(this._menuContent,\n      (ev) => this._setSelected(this._findTargetItem(ev.target), true));\n\n    // Add key handlers to the trigger element as well as the menu if it is an input.\n    this.autoDispose(onKeyElem(_triggerElem, 'keydown', {\n      ArrowDown: () => this._setSelected(this._getNext(1), true),\n      ArrowUp: () => this._setSelected(this._getNext(-1), true),\n    }));\n\n    // Keeps track of the last value as typed by the user.\n    this.search();\n    this.autoDispose(dom.onElem(_triggerElem, 'input', () => this.search()));\n\n    const attachElem = _options.attach === undefined ? document.body : _options.attach;\n    const containerElem = getContainer(_triggerElem, attachElem) ?? document.body;\n    containerElem.appendChild(content);\n\n    this.onDispose(() => { dom.domDispose(content); content.remove(); });\n\n    // Prepare and create the Popper instance, which places the content according to the options.\n    const popperOptions = merge({}, defaultPopperOptions, _options.popperOptions);\n    this._popper = createPopper(_triggerElem, content, popperOptions);\n    this.onDispose(() => this._popper.destroy());\n  }\n\n  public getSelectedItem(): Item|undefined {\n    return this._items.get()[this._selectedIndex];\n  }\n\n  public search(findMatch?: (items: Item[]) => number) {\n    this._updateChoices(this._triggerElem.value, findMatch).catch(reportError);\n  }\n\n  // When the selected element changes, update the classes of the formerly and newly-selected\n  // elements and optionally update the text input.\n  private _setSelected(index: number, updateValue: boolean) {\n    const elem = (this._menuContent.children[index] as HTMLElement) || null;\n    const prev = this._selected;\n    if (elem !== prev) {\n      const clsName = this._options.selectedCssClass || 'selected';\n      if (prev) { prev.classList.remove(clsName); }\n      if (elem) {\n        elem.classList.add(clsName);\n        elem.scrollIntoView({block: 'nearest'});\n      }\n    }\n    this._selected = elem;\n    this._selectedIndex = elem ? index : -1;\n\n    if (updateValue) {\n      // Update trigger's value with the selected choice, or else with the last typed value.\n      if (elem) {\n        this._triggerElem.value = this._options.getItemText(this.getSelectedItem()!);\n      } else {\n        this._triggerElem.value = this._lastAsTyped;\n      }\n    }\n  }\n\n  private _findTargetItem(target: EventTarget|null): number {\n    // Find immediate child of this._menuContent which is an ancestor of ev.target.\n    const elem = findAncestorChild(this._menuContent, target as Element|null);\n    return Array.prototype.indexOf.call(this._menuContent.children, elem);\n  }\n\n  private _getNext(step: 1 | -1): number {\n    // Pretend there is an extra element at the end to mean \"nothing selected\".\n    const xsize = this._items.get().length + 1;\n    const next = (this._selectedIndex + step + xsize) % xsize;\n    return (next === xsize - 1) ? -1 : next;\n  }\n\n  private async _updateChoices(inputVal: string, findMatch?: (items: Item[]) => number): Promise<void> {\n    this._lastAsTyped = inputVal;\n    // TODO We should perhaps debounce the search() call in some clever way, to avoid unnecessary\n    // searches while typing. Today, search() is synchronous in practice, so it doesn't matter.\n    const acResults = await this._options.search(inputVal);\n    this._highlightFunc = acResults.highlightFunc;\n    this._items.set(acResults.items);\n\n    // Plain update() (which is deferred) may be better, but if _setSelected() causes scrolling\n    // before the positions are updated, it causes the entire page to scroll horizontally.\n    this._popper.forceUpdate();\n\n    this._mouseOver.reset();\n\n    let index: number;\n    if (findMatch) {\n      index = findMatch(this._items.get());\n    } else {\n      index = inputVal ? acResults.selectIndex : -1;\n    }\n    this._setSelected(index, false);\n  }\n}\n\n\n// The maxSize modifiers follow recommendations at https://www.npmjs.com/package/popper-max-size-modifier\nconst calcMaxSize = {\n  ...maxSize,\n  options: {padding: 4},\n};\n\nconst applyMaxSize: Modifier<any, any> = {\n  name: 'applyMaxSize',\n  enabled: true,\n  phase: 'beforeWrite',\n  requires: ['maxSize'],\n  fn({state}: any) {\n    // The `maxSize` modifier provides this data\n    const {height} = state.modifiersData.maxSize;\n    Object.assign(state.styles.popper, {\n      maxHeight: `${Math.max(160, height)}px`\n    });\n  }\n};\n\nexport const defaultPopperOptions: Partial<PopperOptions> = {\n  placement: 'bottom-start',\n  modifiers: [\n    calcMaxSize,\n    applyMaxSize,\n    {name: \"computeStyles\", options: {gpuAcceleration: false}},\n  ],\n};\n\n\n/**\n * Helper that finds the container according to attachElem. Null means\n * elem.parentNode; string is a selector for the closest matching ancestor, e.g. 'body'.\n */\n function getContainer(elem: Element, attachElem: Element|string|null): Node|null {\n  return (typeof attachElem === 'string') ? elem.closest(attachElem) :\n    (attachElem || elem.parentNode);\n}\n\n/**\n * Helper function which returns the direct child of ancestor which is an ancestor of elem, or\n * null if elem is not a descendant of ancestor.\n */\nexport function findAncestorChild(ancestor: Element, elem: Element|null): Element|null {\n  while (elem && elem.parentElement !== ancestor) {\n    elem = elem.parentElement;\n  }\n  return elem;\n}\n\n/**\n * A version of dom.onElem('mouseover') that doesn't start firing until there is first a 'mousemove'.\n * This way if an element is created under the mouse cursor (triggered by the keyboard, for\n * instance) it's not immediately highlighted, but only when a user moves the mouse.\n * Returns an object with a reset() method, which restarts the wait for mousemove.\n */\nexport function attachMouseOverOnMove<T extends EventTarget>(elem: T, callback: EventCB<MouseEvent, T>) {\n  let lis: IDisposable|undefined;\n  function setListener(eventType: 'mouseover'|'mousemove', cb: EventCB<MouseEvent, T>) {\n    if (lis) { lis.dispose(); }\n    lis = dom.onElem(elem, eventType, cb);\n  }\n  function reset() {\n    setListener('mousemove', (ev, _elem) => {\n      setListener('mouseover', callback);\n      callback(ev, _elem);\n    });\n  }\n  reset();\n  return {reset};\n}\n\nconst cssMenuWrap = styled('div', `\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  outline: none;\n`);\n","import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';\n\nconst G = getBrowserGlobals('document', 'window');\n\n/**\n * Copy some text to the clipboard, by hook or by crook.\n */\nexport async function copyToClipboard(txt: string) {\n  // If present and we have permission to use it, the navigator.clipboard interface\n  // is convenient.  This method works in non-headless tests, and regular chrome\n  // and firefox.\n  if (G.window.navigator && G.window.navigator.clipboard && G.window.navigator.clipboard.writeText) {\n    try {\n      await G.window.navigator.clipboard.writeText(txt);\n      return;\n    } catch (e) {\n      // no joy, try another way.\n    }\n  }\n  // Otherwise fall back on document.execCommand('copy'), which requires text in\n  // the dom to be selected.  Implementation here based on:\n  //   https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f\n  // This fallback takes effect at least in headless tests, and in Safari.\n  const stash = G.document.createElement('textarea');\n  stash.value = txt;\n  stash.setAttribute('readonly', '');\n  stash.style.position = 'absolute';\n  stash.style.left = '-10000px';\n  G.document.body.appendChild(stash);\n  const selection = G.document.getSelection().rangeCount > 0 && G.document.getSelection().getRangeAt(0);\n  stash.select();\n  G.document.execCommand('copy');\n  G.document.body.removeChild(stash);\n  if (selection) {\n    G.document.getSelection().removeAllRanges();\n    G.document.getSelection().addRange(selection);\n  }\n}\n","import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';\nimport {TestState} from 'app/common/TestState';\n\nconst G = getBrowserGlobals('window');\n\nexport function setTestState(state: Partial<TestState>) {\n  if (!('testGrist' in G.window)) {\n    G.window.testGrist = {};\n  }\n  Object.assign(G.window.testGrist, state);\n}\n","import {dom, IDomArgs, Observable, styled} from 'grainjs';\n\n// Shadow css settings for member scroll top and bottom.\nconst SHADOW_TOP = 'inset 0 4px 6px 0 rgba(217,217,217,0.4)';\nconst SHADOW_BTM = 'inset 0 -4px 6px 0 rgba(217,217,217,0.4)';\n\n/**\n * Creates a scroll div used in the UserManager and moveDoc menus to display\n * shadows at the top and bottom of a list of scrollable items.\n */\nexport function shadowScroll(...args: IDomArgs<HTMLDivElement>) {\n  // Observables to indicate the scroll position.\n  const scrollTop = Observable.create(null, true);\n  const scrollBtm = Observable.create(null, true);\n  return cssScrollMenu(\n    dom.autoDispose(scrollTop),\n    dom.autoDispose(scrollBtm),\n    // Update scroll positions on init and on scroll.\n    (elem) => { setTimeout(() => scrollBtm.set(isAtScrollBtm(elem)), 0); },\n    dom.on('scroll', (_, elem) => {\n      scrollTop.set(isAtScrollTop(elem));\n      scrollBtm.set(isAtScrollBtm(elem));\n    }),\n    // Add shadows on the top/bottom if the list is scrolled away from either.\n    dom.style('box-shadow', (use) => {\n      const shadows = [use(scrollTop) ? null : SHADOW_TOP, use(scrollBtm) ? null : SHADOW_BTM];\n      return shadows.filter(css => css).join(', ');\n    }),\n    ...args\n  );\n}\n\n// Indicates that an element is currently scrolled such that the top of the element is visible.\nfunction isAtScrollTop(elem: Element): boolean {\n  return elem.scrollTop === 0;\n}\n\n// Indicates that an element is currently scrolled such that the bottom of the element is visible.\n// It is expected that the elem arg has the offsetHeight property set.\nfunction isAtScrollBtm(elem: HTMLElement): boolean {\n  return elem.scrollTop >= (elem.scrollHeight - elem.offsetHeight);\n}\n\nconst cssScrollMenu = styled('div', `\n  flex: 1 1 0;\n  width: 100%;\n  overflow-y: auto;\n`);\n"],"names":[],"sourceRoot":""}