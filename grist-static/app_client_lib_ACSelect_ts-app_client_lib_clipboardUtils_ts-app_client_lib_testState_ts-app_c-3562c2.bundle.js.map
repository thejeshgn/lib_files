{"version":3,"file":"app_client_lib_ACSelect_ts-app_client_lib_clipboardUtils_ts-app_client_lib_testState_ts-app_c-3562c2.bundle.js","mappings":"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","sources":["./app/client/lib/ACIndex.ts?","./app/client/lib/ACSelect.ts?","./app/client/lib/clipboardUtils.ts?","./app/client/lib/testState.ts?","./app/client/ui/inputs.ts?","./app/client/ui/shadowScroll.ts?"],"sourcesContent":["/**\n * A search index for auto-complete suggestions.\n *\n * This implementation indexes words, and suggests items based on a best-match score, including\n * amount of overlap and position of words. It searches case-insensitively and only at the start\n * of words. E.g. searching for \"Blue\" would match \"Blu\" in \"Lavender Blush\", but searching for\n * \"lush\" would only match the \"L\" in \"Lavender\".\n */\n\nimport {localeCompare, nativeCompare, sortedIndex} from 'app/common/gutil';\nimport {DomContents} from 'grainjs';\nimport escapeRegExp = require(\"lodash/escapeRegExp\");\nimport deburr = require(\"lodash/deburr\");\nimport split = require(\"lodash/split\");\n\nexport interface ACItem {\n  // This should be a trimmed lowercase version of the item's text. It may be an accessor.\n  // Note that items with empty cleanText are never suggested.\n  cleanText: string;\n}\n\n// Returns a trimmed, lowercase version of a string,\n// from which accents and other diacritics have been removed,\n// so that autocomplete is case- and accent-insensitive.\nexport function normalizeText(text: string): string {\n  return deburr(text).trim().toLowerCase();\n}\n\n// Regexp used to split text into words; includes nearly all punctuation. This means that\n// \"foo-bar\" may be searched by \"bar\", but it's impossible to search for punctuation itself (e.g.\n// \"a-b\" and \"a+b\" are not distinguished). (It's easy to exclude unicode punctuation too if the\n// need arises, see https://stackoverflow.com/a/25575009/328565).\nconst wordSepRegexp = /[\\s!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]+/;\n\n/**\n * An auto-complete index, which simply allows searching for a string.\n */\nexport interface ACIndex<Item extends ACItem> {\n  search(searchText: string): ACResults<Item>;\n}\n\n// Splits text into an array of pieces, with odd-indexed pieces being the ones to highlight.\nexport type HighlightFunc = (text: string) => string[];\n\nexport const highlightNone: HighlightFunc = (text) => [text];\n\n/**\n * AutoComplete results include the suggested items, which one to highlight, and a function for\n * highlighting the matched portion of each item.\n */\nexport interface ACResults<Item extends ACItem> {\n  // Matching items in order from best match to worst.\n  items: Item[];\n\n  // May be used to highlight matches using buildHighlightedDom().\n  highlightFunc: HighlightFunc;\n\n  // index of a good match (normally 0), or -1 if no great match\n  selectIndex: number;\n}\n\ninterface Word {\n  word: string;     // The indexed word\n  index: number;    // Index into _allItems for the item containing this word.\n  pos: number;      // Position of the word within the item where it occurred.\n}\n\n/**\n * Implements a search index. It doesn't currently support updates; when any values change, the\n * index needs to be rebuilt from scratch.\n */\nexport class ACIndexImpl<Item extends ACItem> implements ACIndex<Item> {\n  private _allItems: Item[];\n\n  // All words from _allItems, sorted.\n  private _words: Word[];\n\n  // Creates an index for the given list of items.\n  // The max number of items to suggest may be set using _maxResults (default is 50).\n  // If _keepOrder is true, best matches will be suggested in the order they occur in items,\n  // rather than order by best score.\n  constructor(items: Item[], private _maxResults: number = 50, private _keepOrder = false) {\n    this._allItems = items.slice(0);\n\n    // Collects [word, occurrence, position] tuples for all words in _allItems.\n    const allWords: Word[] = [];\n    for (let index = 0; index < this._allItems.length; index++) {\n      const item = this._allItems[index];\n      const words = item.cleanText.split(wordSepRegexp).filter(w => w);\n      for (let pos = 0; pos < words.length; pos++) {\n        allWords.push({word: words[pos], index, pos});\n      }\n    }\n\n    allWords.sort((a, b) => localeCompare(a.word, b.word));\n    this._words = allWords;\n  }\n\n\n  // The main search function. SearchText will be cleaned (trimmed and lowercased) at the start.\n  // Empty search text returns the first N items in the search universe.\n  public search(searchText: string): ACResults<Item> {\n    const cleanedSearchText = normalizeText(searchText);\n    const searchWords = cleanedSearchText.split(wordSepRegexp).filter(w => w);\n\n    // Maps item index in _allItems to its score.\n    const myMatches = new Map<number, number>();\n\n    if (searchWords.length > 0) {\n      // For each of searchWords, go through items with an overlap, and update their scores.\n      for (let k = 0; k < searchWords.length; k++) {\n        const searchWord = searchWords[k];\n        for (const [itemIndex, score] of this._findOverlaps(searchWord, k)) {\n          myMatches.set(itemIndex, (myMatches.get(itemIndex) || 0) + score);\n        }\n      }\n\n      // Give an extra point to items that start with the searchText.\n      for (const [itemIndex, score] of myMatches) {\n        if (this._allItems[itemIndex].cleanText.startsWith(cleanedSearchText)) {\n          myMatches.set(itemIndex, score + 1);\n        }\n      }\n    }\n\n    // Array of pairs [itemIndex, score], sorted by score (desc) and itemIndex.\n    const sortedMatches = Array.from(myMatches)\n      .sort((a, b) => nativeCompare(b[1], a[1]) || nativeCompare(a[0], b[0]))\n      .slice(0, this._maxResults);\n\n    const itemIndices: number[] = sortedMatches.map(([index, score]) => index);\n\n    // Append enough non-matching indices to reach maxResults.\n    for (let i = 0; i < this._allItems.length && itemIndices.length < this._maxResults; i++) {\n      if (this._allItems[i].cleanText && !myMatches.has(i)) {\n        itemIndices.push(i);\n      }\n    }\n\n    if (this._keepOrder) {\n      itemIndices.sort(nativeCompare);\n    }\n    const items = itemIndices.map(index => this._allItems[index]);\n\n    if (!cleanedSearchText) {\n      // In this case we are just returning the first few items.\n      return {items, highlightFunc: highlightNone, selectIndex: -1};\n    }\n\n    const highlightFunc = highlightMatches.bind(null, searchWords);\n\n    // If we have a best match, and any word in it actually starts with the search text, report it\n    // as a default selection for highlighting. Otherwise, no item will be auto-selected.\n    let selectIndex = sortedMatches.length > 0 ? itemIndices.indexOf(sortedMatches[0][0]) : -1;\n    if (selectIndex >= 0 && !startsWithText(items[selectIndex], cleanedSearchText, searchWords)) {\n      selectIndex = -1;\n    }\n    return {items, highlightFunc, selectIndex};\n  }\n\n  /**\n   * Given one of the search words, looks it up in the indexed list of words and searches up and\n   * down the list for all words that share a prefix with it. Each such word contributes something\n   * to the score of the index entry it is a part of.\n   *\n   * Returns a Map from the index entry (index into _allItems) to the score which this searchWord\n   * contributes to it.\n   *\n   * The searchWordPos argument is the position of searchWord in the overall search text (e.g. 0\n   * if it's the first word). It is used for the position bonus, to give higher scores to entries\n   * whose words occur in the same order as in the search text.\n   */\n  private _findOverlaps(searchWord: string, searchWordPos: number): Map<number, number> {\n    const insertIndex = sortedIndex<{word: string}>(this._words, {word: searchWord},\n      (a, b) => localeCompare(a.word, b.word));\n\n    // Maps index of item to its score.\n    const scored = new Map<number, number>();\n\n    // Search up and down the list, accepting smaller and smaller overlap.\n    for (const step of [1, -1]) {\n      let prefix = searchWord;\n      let index = insertIndex + (step > 0 ? 0 : -1);\n      while (prefix && index >= 0 && index < this._words.length) {\n        for ( ; index >= 0 && index < this._words.length; index += step) {\n          const wordEntry = this._words[index];\n          // Once we reach a word that doesn't start with our prefix, break this loop, so we can\n          // reduce the length of the prefix and keep scanning.\n          if (!wordEntry.word.startsWith(prefix)) { break; }\n\n          // The contribution of this word's to the score consists primarily of the length of\n          // overlap (i.e. length for the current prefix).\n          const baseScore = prefix.length;\n\n          // To this we add 1 if the word matches exactly.\n          const fullWordBonus = (wordEntry.word === searchWord ? 1 : 0);\n\n          // To prefer matches where words occur in the same order as searched (e.g. searching for\n          // \"Foo B\" should prefer \"Foo Bar\" over \"Bar Foo\"), we give a bonus based on the\n          // position of the word in the search text and the entry text. (If positions match as\n          // 0:0 and 1:1, the total position bonus is 2^0+2^(-2)=1.25; while the bonus from 0:1\n          // and 1:0 would be 2^(-1) + 2^(-1)=1.0.)\n          const positionBonus = Math.pow(2, -(searchWordPos + wordEntry.pos));\n\n          const itemScore = baseScore + fullWordBonus + positionBonus;\n          // Each search word contributes only one score (e.g. a search for \"Foo\" will partially\n          // match both words in \"forty five\", but only the higher of the matches will count).\n          if (itemScore >= (scored.get(wordEntry.index) || 0)) {\n            scored.set(wordEntry.index, itemScore);\n          }\n        }\n        prefix = prefix.slice(0, -1);\n      }\n    }\n    return scored;\n  }\n}\n\n\nexport type BuildHighlightFunc = (match: string) => DomContents;\n\n/**\n * Converts text to DOM with matching bits of text rendered using highlight(match) function.\n */\nexport function buildHighlightedDom(\n  text: string, highlightFunc: HighlightFunc, highlight: BuildHighlightFunc\n): DomContents {\n  if (!text) { return text; }\n  const parts = highlightFunc(text);\n  return parts.map((part, k) => k % 2 ? highlight(part) : part);\n}\n\n\n// Same as wordSepRegexp, but with capturing parentheses.\nconst wordSepRegexpParen = new RegExp(`(${wordSepRegexp.source})`);\n\n/**\n * Splits text into pieces, with odd-numbered pieces the ones matching a prefix of some\n * searchWord, i.e. the ones to highlight.\n */\nfunction highlightMatches(searchWords: string[], text: string): string[] {\n  const textParts = text.split(wordSepRegexpParen);\n  const outputs = [''];\n  for (let i = 0; i < textParts.length; i += 2) {\n    const word = textParts[i];\n    const separator = textParts[i + 1] || '';\n    // deburr (remove diacritics) was used to produce searchWords, so `word` needs to match that.\n    const prefixLen = findLongestPrefixLen(deburr(word).toLowerCase(), searchWords);\n    if (prefixLen === 0) {\n      outputs[outputs.length - 1] += word + separator;\n    } else {\n      // Split into unicode 'characters' that keep diacritics combined\n      const chars = split(word, '');\n      outputs.push(\n        chars.slice(0, prefixLen).join(''),\n        chars.slice(prefixLen).join('') + separator\n      );\n    }\n  }\n  return outputs;\n}\n\nfunction findLongestPrefixLen(text: string, choices: string[]): number {\n  return choices.reduce((max, choice) => Math.max(max, findCommonPrefixLength(text, choice)), 0);\n}\n\nfunction findCommonPrefixLength(text1: string, text2: string): number {\n  let i = 0;\n  while (i < text1.length && text1[i] === text2[i]) { ++i; }\n  return i;\n}\n\n/**\n * Checks whether `item` starts with `text`, or whether all words of text are prefixes of the\n * words of `item`. (E.g. it would return true if item is \"New York\", and text is \"ne yo\".)\n */\nfunction startsWithText(item: ACItem, text: string, searchWords: string[]): boolean {\n  if (item.cleanText.startsWith(text)) { return true; }\n\n  const regexp = new RegExp(searchWords.map(w => `\\\\b` + escapeRegExp(w)).join('.*'));\n  const cleanText = item.cleanText.split(wordSepRegexp).join(' ');\n  return regexp.test(cleanText);\n}\n","import {ACIndex, ACItem, buildHighlightedDom} from 'app/client/lib/ACIndex';\nimport {Autocomplete, IAutocompleteOptions} from 'app/client/lib/autocomplete';\nimport {theme} from \"app/client/ui2018/cssVars\";\nimport {icon} from \"app/client/ui2018/icons\";\nimport {menuCssClass} from 'app/client/ui2018/menus';\nimport {dom, DomElementArg, Holder, IDisposableOwner, Observable, styled} from 'grainjs';\n\nexport interface ACSelectItem extends ACItem {\n  value: string;\n  label: string;\n}\n\n/**\n * Builds a text input with an autocomplete dropdown.\n * Note that because it is currently only used in the right-side panel, it is designed to avoid\n * keeping focus.\n */\nexport function buildACSelect(\n  owner: IDisposableOwner,\n  options: {\n    disabled?: Observable<boolean>,\n    acIndex: ACIndex<ACSelectItem>,\n    valueObs: Observable<string>,\n    save: (value: string, item: ACSelectItem|undefined) => Promise<void>|void\n  },\n  ...args: DomElementArg[]\n) {\n  const {acIndex, valueObs, save} = options;\n  const acHolder = Holder.create<Autocomplete<ACSelectItem>>(owner);\n  let textInput: HTMLInputElement;\n\n  const isOpen = () => !acHolder.isEmpty();\n  const acOpen = () => acHolder.isEmpty() && Autocomplete.create(acHolder, textInput, acOptions);\n  const acClose = () => acHolder.clear();\n  const finish = () => { acClose(); textInput.blur(); };\n  const revert = () => { textInput.value = valueObs.get(); finish(); };\n  const commitOrRevert = async () => { (await commitIfValid()) || revert(); };\n  const openOrCommit = () => { isOpen() ? commitOrRevert().catch(() => {}) : acOpen(); };\n\n  const commitIfValid = async () => {\n    const item = acHolder.get()?.getSelectedItem();\n    if (item) {\n      textInput.value = item.value;\n    }\n    textInput.disabled = true;\n    try {\n      await save(textInput.value, item);\n      finish();\n      return true;\n    } catch (e) {\n      return false;\n    } finally {\n      textInput.disabled = false;\n    }\n  };\n\n  const onMouseDown = (ev: MouseEvent) => {\n    ev.preventDefault();    // Don't let it affect focus, since we focus/blur manually.\n    if (options.disabled?.get()) {\n      return;\n    }\n    if (!isOpen()) { textInput.focus(); }\n    openOrCommit();\n  };\n\n  const acOptions: IAutocompleteOptions<ACSelectItem> = {\n    menuCssClass: `${menuCssClass} test-acselect-dropdown`,\n    search: async (term: string) => acIndex.search(term),\n    renderItem: (item, highlightFunc) =>\n      cssSelectItem(buildHighlightedDom(item.label, highlightFunc, cssMatchText)),\n    getItemText: (item) => item.value,\n    onClick: commitIfValid,\n  };\n\n  return cssSelectBtn(\n    textInput = cssInput({type: 'text'},\n      dom.prop('value', valueObs),\n      dom.on('focus', (ev, elem) => elem.select()),\n      dom.on('blur', commitOrRevert),\n      dom.prop(\"disabled\", (use) => options.disabled ? use(options.disabled) : false),\n      dom.onKeyDown({\n        Escape: revert,\n        Enter: openOrCommit,\n        ArrowDown: acOpen,\n        Tab: commitIfValid,\n      }),\n      dom.on('input', acOpen),\n    ),\n    dom.on('mousedown', onMouseDown),\n    cssIcon('Dropdown'),\n    ...args\n  );\n}\n\nconst cssSelectBtn = styled('div', `\n  position: relative;\n  width: 100%;\n  height: 30px;\n  color: ${theme.selectButtonFg};\n  --icon-color: ${theme.selectButtonFg};\n`);\n\nexport const cssSelectItem = styled('li', `\n  color: ${theme.menuItemFg};\n  display: block;\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  outline: none;\n  padding: var(--weaseljs-menu-item-padding, 8px 24px);\n  cursor: pointer;\n\n  &.selected {\n    background-color: ${theme.menuItemSelectedBg};\n    color:            ${theme.menuItemSelectedFg};\n  }\n`);\n\nconst cssInput = styled('input', `\n  color: ${theme.inputFg};\n  background-color: ${theme.inputBg};\n  appearance: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  height: 100%;\n  width: 100%;\n  padding: 0 6px;\n  outline: none;\n  border: 1px solid ${theme.inputBorder};\n  border-radius: 3px;\n  cursor: pointer;\n  line-height: 16px;\n  cursor: pointer;\n\n  &:disabled {\n    color: ${theme.inputDisabledFg};\n    background-color: ${theme.inputDisabledBg};\n  }\n  &:focus {\n    cursor: initial;\n    outline: none;\n    box-shadow: 0px 0px 2px 2px ${theme.inputFocus};\n  }\n  &::placeholder {\n    color: ${theme.inputPlaceholderFg};\n  }\n`);\n\nconst cssIcon = styled(icon, `\n  position: absolute;\n  right: 6px;\n  top: calc(50% - 8px);\n`);\n\nconst cssMatchText = styled('span', `\n  color: ${theme.autocompleteMatchText};\n  .selected > & {\n    color: ${theme.autocompleteSelectedMatchText};\n  }\n`);\n","import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';\n\nconst G = getBrowserGlobals('document', 'window');\n\n/**\n * Copy text or data to the clipboard.\n */\nexport async function copyToClipboard(data: string | ClipboardItem) {\n  if (typeof data === 'string') {\n    await copyTextToClipboard(data);\n  } else {\n    await copyDataToClipboard(data);\n  }\n}\n\n/**\n * Copy text to the clipboard.\n */\nasync function copyTextToClipboard(txt: string) {\n  // If present and we have permission to use it, the navigator.clipboard interface\n  // is convenient.  This method works in non-headless tests, and regular chrome\n  // and firefox.\n  if (G.window.navigator && G.window.navigator.clipboard && G.window.navigator.clipboard.writeText) {\n    try {\n      await G.window.navigator.clipboard.writeText(txt);\n      return;\n    } catch (e) {\n      // no joy, try another way.\n    }\n  }\n  // Otherwise fall back on document.execCommand('copy'), which requires text in\n  // the dom to be selected.  Implementation here based on:\n  //   https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f\n  // This fallback takes effect at least in headless tests, and in Safari.\n  const stash = G.document.createElement('textarea');\n  stash.value = txt;\n  stash.setAttribute('readonly', '');\n  stash.style.position = 'absolute';\n  stash.style.left = '-10000px';\n  G.document.body.appendChild(stash);\n  const selection = G.document.getSelection().rangeCount > 0 && G.document.getSelection().getRangeAt(0);\n  stash.select();\n  G.document.execCommand('copy');\n  G.document.body.removeChild(stash);\n  if (selection) {\n    G.document.getSelection().removeAllRanges();\n    G.document.getSelection().addRange(selection);\n  }\n}\n\n/**\n * Copy data to the clipboard.\n */\nasync function copyDataToClipboard(data: ClipboardItem) {\n  if (!G.window.navigator?.clipboard?.write) {\n    throw new Error('navigator.clipboard.write is not supported on this browser');\n  }\n\n  await G.window.navigator.clipboard.write([data]);\n}\n\n/**\n * Read text from the clipboard.\n */\nexport function readTextFromClipboard(): Promise<string> {\n  if (!G.window.navigator?.clipboard?.readText) {\n    throw new Error('navigator.clipboard.readText is not supported on this browser');\n  }\n\n  return G.window.navigator.clipboard.readText();\n}\n\n/**\n * Read data from the clipboard.\n */\nexport function readDataFromClipboard(): Promise<ClipboardItem[]> {\n  if (!G.window.navigator?.clipboard?.read) {\n    throw new Error('navigator.clipboard.read is not supported on this browser');\n  }\n\n  return G.window.navigator.clipboard.read();\n}\n","import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';\nimport {TestState} from 'app/common/TestState';\n\nconst G = getBrowserGlobals('window');\n\nexport function setTestState(state: Partial<TestState>) {\n  if (!('testGrist' in G.window)) {\n    G.window.testGrist = {};\n  }\n  Object.assign(G.window.testGrist, state);\n}\n","import {theme, vars} from 'app/client/ui2018/cssVars';\nimport {dom, DomElementArg, IDomArgs, IInputOptions, Observable, styled, subscribe} from 'grainjs';\n\nexport const cssInput = styled('input', `\n  font-size: ${vars.mediumFontSize};\n  height: 48px;\n  line-height: 20px;\n  width: 100%;\n  padding: 14px;\n  border: 1px solid ${theme.inputBorder};\n  border-radius: 4px;\n  outline: none;\n  display: block;\n  color: ${theme.inputFg};\n  background-color: ${theme.inputBg};\n\n  &::placeholder {\n    color: ${theme.inputPlaceholderFg};\n  }\n\n  &[type=number] {\n    -moz-appearance: textfield;\n  }\n  &[type=number]::-webkit-inner-spin-button,\n  &[type=number]::-webkit-outer-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n\n  &-invalid {\n    border: 1px solid ${theme.inputInvalid};\n  }\n\n  &-valid {\n    border: 1px solid ${theme.inputValid};\n  }\n`);\n\n/**\n * Builds a text input that updates `obs` as you type.\n */\nexport function textInput(obs: Observable<string>, ...args: DomElementArg[]): HTMLInputElement {\n  return cssInput(\n    dom.prop('value', obs),\n    dom.on('input', (_e, elem) => obs.set(elem.value)),\n    ...args,\n  );\n}\n\nexport function textarea(\n  obs: Observable<string>, options: IInputOptions, ...args: IDomArgs<HTMLTextAreaElement>\n): HTMLTextAreaElement {\n\n  const isValid = options.isValid;\n\n  function setValue(elem: HTMLTextAreaElement) {\n    obs.set(elem.value);\n    if (isValid) { isValid.set(elem.validity.valid); }\n  }\n\n  return dom('textarea', ...args,\n    dom.prop('value', obs),\n    (isValid ?\n      (elem) => dom.autoDisposeElem(elem,\n        subscribe(obs, (use) => isValid.set(elem.checkValidity()))) :\n      null),\n    options.onInput ? dom.on('input', (e, elem) => setValue(elem)) : null,\n    dom.on('change', (e, elem) => setValue(elem)),\n  );\n}","import {dom, IDomArgs, Observable, styled} from 'grainjs';\n\n// Shadow css settings for member scroll top and bottom.\nconst SHADOW_TOP = 'inset 0 4px 6px 0 rgba(217,217,217,0.4)';\nconst SHADOW_BTM = 'inset 0 -4px 6px 0 rgba(217,217,217,0.4)';\n\n/**\n * Creates a scroll div used in the UserManager and moveDoc menus to display\n * shadows at the top and bottom of a list of scrollable items.\n */\nexport function shadowScroll(...args: IDomArgs<HTMLDivElement>) {\n  // Observables to indicate the scroll position.\n  const scrollTop = Observable.create(null, true);\n  const scrollBtm = Observable.create(null, true);\n  return cssScrollMenu(\n    dom.autoDispose(scrollTop),\n    dom.autoDispose(scrollBtm),\n    // Update scroll positions on init and on scroll.\n    (elem) => { setTimeout(() => scrollBtm.set(isAtScrollBtm(elem)), 0); },\n    dom.on('scroll', (_, elem) => {\n      scrollTop.set(isAtScrollTop(elem));\n      scrollBtm.set(isAtScrollBtm(elem));\n    }),\n    // Add shadows on the top/bottom if the list is scrolled away from either.\n    dom.style('box-shadow', (use) => {\n      const shadows = [use(scrollTop) ? null : SHADOW_TOP, use(scrollBtm) ? null : SHADOW_BTM];\n      return shadows.filter(css => css).join(', ');\n    }),\n    ...args\n  );\n}\n\n// Indicates that an element is currently scrolled such that the top of the element is visible.\nfunction isAtScrollTop(elem: Element): boolean {\n  return elem.scrollTop === 0;\n}\n\n// Indicates that an element is currently scrolled such that the bottom of the element is visible.\n// It is expected that the elem arg has the offsetHeight property set.\nfunction isAtScrollBtm(elem: HTMLElement): boolean {\n  return elem.scrollTop >= (elem.scrollHeight - elem.offsetHeight);\n}\n\nconst cssScrollMenu = styled('div', `\n  flex: 1 1 0;\n  width: 100%;\n  overflow-y: auto;\n`);\n"],"names":[],"sourceRoot":""}